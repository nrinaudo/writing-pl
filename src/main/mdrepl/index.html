<!Doctype html>
<html>
    <head>
        <title>Programming a language</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Programming a language

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]

---

class: center, middle
name: ast

# Representing code

---

```scala
&#x200B;
&#x200B;
&#x200B;
```

```scala
1
```

---

```scala
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
*1 `+ 2`
```
]

---

.diff-add[
```scala
*&#x200B;`enum Expr:`
&#x200B;
&#x200B;
```
]

```scala
1 + 2
```

---

.diff-add[
```scala
enum Expr:
* `case Num()`
&#x200B;
```
]

```scala
1 + `2`
```

---

.diff-add[
```scala
enum Expr:
* case Num(`value: Int`)
&#x200B;
```
]

```scala
1 + `2`
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* `case Add()`
```
]

```scala
1 `+` 2
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(`lhs: Num`)
```
]

```scala
&#x200B;`1` + 2
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: Num`, rhs: Num`)
```
]

```scala
1 + `2`
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Add(lhs: Num, rhs: Num)
import Expr.*
```

---

```scala
&#x200B;`Num value` ⇓ ???
&#x200B;
&#x200B;
```

```scala
1 + `2`
```

---

```scala
Num value `⇓` ???
&#x200B;
&#x200B;
```

```scala
1 + `2`
```

---

.diff-rm[
```scala
*Num value ⇓ `???`
&#x200B;
&#x200B;
```
]

```scala
1 + `2`
```

---

.diff-add[
```scala
*Num value ⇓ `value`
&#x200B;
&#x200B;
```
]

```scala
1 + `2`
```

---

```scala
&#x200B;`Add lhs rhs` ⇓ ???
&#x200B;
&#x200B;
```

```scala
1 + 2
```

---

.diff-rm[
```scala
*Add lhs rhs ⇓ `???`
&#x200B;
&#x200B;
```
]

```scala
1 + 2
```

---

.diff-add[
```scala
*Add lhs rhs ⇓ `lhs + rhs`
&#x200B;
&#x200B;
```
]

```scala
1 + 2
```

---

```scala
Add `lhs` `rhs` ⇓ lhs + rhs
&#x200B;
&#x200B;
```

```scala
1 + 2
```

---

.diff-add[
```scala
*&#x200B;`lhs ⇓ v₁`
Add lhs rhs ⇓ lhs + rhs
&#x200B;
```
]

```scala
&#x200B;`1` + 2
```

---

.diff-add[
```scala
*lhs ⇓ v₁      `rhs ⇓ v₂`
Add lhs rhs ⇓ lhs + rhs
&#x200B;
```
]

```scala
1 + `2`
```

---

.diff-add[
```scala
lhs ⇓ v₁      rhs ⇓ v₂
*&#x200B;`⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯`
Add lhs rhs ⇓ lhs + rhs
```
]

```scala
1 + 2
```

---

.diff-rm[
```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Add lhs rhs ⇓ `lhs + rhs`
```
]

```scala
&#x200B;`1 + 2`
```

---

.diff-add[
```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Add lhs rhs ⇓ `v₁ + v₂`
```
]

```scala
&#x200B;`1 + 2`
```

---

```scala
def interpret(expr: Expr): ??? =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```scala
def interpret(`expr: Expr`): ??? =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-rm[
```scala
*def interpret(expr: Expr): `???` =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
*def interpret(expr: Expr): `Int` =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
*def interpret(expr: Expr): Int = `expr match`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
* `case Num(value)    =>`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;`Num value` ⇓ value
```

---

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
* case Num(value)    => `value`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
Num value ⇓ `value`
```

---

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* `case Add(lhs, rhs) =>`
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Add lhs rhs` ⇓ v₁ + v₂
```

---

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* case Add(lhs, rhs) => `add(lhs, rhs)`
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs ⇓ v₁`      `rhs ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ `v₁ + v₂`
```

---

```scala
def add(lhs: Num, rhs: Num) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

.diff-add[
```scala
def add(lhs: Num, rhs: Num) =
* `val v1 = interpret(lhs)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs ⇓ v₁`      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

.diff-add[
```scala
def add(lhs: Num, rhs: Num) =
  val v1 = interpret(lhs)
* `val v2 = interpret(rhs)`
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ v₁      `rhs ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

.diff-add[
```scala
def add(lhs: Num, rhs: Num) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
* `v1 + v2`
```
]

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ `v₁ + v₂`
```

```scala repl:invisible
def add(lhs: Num, rhs: Num) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)

  v1 + v2

def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
  case Add(lhs, rhs) => add(lhs, rhs)
```

---

```ocaml
1 + 2
```

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
```

---

```ocaml
1 `+` 2
```

```scala
val expr = `Add`(Num(1), Num(2))
```


```scala
interpret(expr)
```

---

```ocaml
&#x200B;`1` + 2
```

```scala
val expr = Add(`Num(1)`, Num(2))
```

```scala
interpret(expr)
```

---

```ocaml
1 + `2`
```

```scala
val expr = Add(Num(1), `Num(2)`)
```

```scala
interpret(expr)
```

---

```ocaml
1 + 2
```

```scala repl
val expr = Add(Num(1), Num(2))
```

```scala repl
interpret(expr)
```

---

.diff-add[
```ocaml
*&#x200B;`(`1 + 2`)`
```
]

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
// val res0: Int = 3
```

---

.diff-add[
```ocaml
*&#x200B;(`(`1`)`     +       `((`2`))`)
```
]

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
// val res0: Int = 3
```

---

.center[![](img/ast-root.svg)]

```ocaml
1 `+` 2
```

---

.center[![](img/ast-leaves.svg)]

```ocaml
&#x200B;`1` + `2`
```

---

.center[![](img/ast.svg)]

```ocaml
1 + 2
```

---

.center[![](img/ast-rhs-2-remove.svg)]

.diff-rm[
```ocaml
*1 + `2`
```
]

---

.center[![](img/ast-rhs-add-what.svg)]

.diff-add[
```ocaml
*1 + `(2 + 3)`
```
]

---

.center[![](img/ast-rhs-add-from-num.svg)]

.diff-rm[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: `Num`, rhs: `Num`)
```
]

---

.center[![](img/ast-rhs-add-to-num.svg)]

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: `Expr`, rhs: `Expr`)
```
]

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
import Expr.*
```

---

```scala
def add(lhs: Num, rhs: Num) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)

  v1 + v2
```

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

.diff-rm[
```scala
*def add(lhs: `Num`, rhs: `Num`) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)

  v1 + v2
```
]

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

.diff-add[
```scala
*def add(lhs: `Expr`, rhs: `Expr`) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)

  v1 + v2
```
]

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

---

```scala
def add(lhs: Expr, rhs: Expr) =
  `val v1 = interpret(lhs)`
  val v2 = interpret(rhs)

  v1 + v2
```

```scala
&#x200B;`lhs ⇓ v₁`      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```
---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  `val v2 = interpret(rhs)`

  v1 + v2
```

```scala
lhs ⇓ v₁      `rhs ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
```

```scala repl:invisible
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)

  v1 + v2

def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
  case Add(lhs, rhs) => add(lhs, rhs)
```

---

```ocaml
1 + 2
```

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
```

---

.diff-rm[
```ocaml
*1 + `2`
```
]

.diff-rm[
```scala
*val expr = Add(Num(1), `Num(2)`)
```
]

```scala
interpret(expr)
```

---

.diff-add[
```ocaml
*1 + `(2 + 3)`
```
]

.diff-add[
```scala
*val expr = Add(Num(1), `Add(Num(2), Num(3))`)
```
]

```scala
interpret(expr)
```

---

```ocaml
1 + (2 + 3)
```

```scala repl
val expr = Add(Num(1), Add(Num(2), Num(3)))
```

```scala repl
interpret(expr)
```

---

## [Key takeaways](#conclusion)

--

* Source code is represented as a recursive sum type

--

* This is called an AST

--

* Interpretation is done through pattern matching

---

class: center, middle
name: conditionals

# Taking decisions

---

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond` ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```ocaml
&#x200B;`if` true then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond `pred` ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred `onT` ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred onT `onF` ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

.diff-add[
```scala
*&#x200B;`pred ⇓ ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

.diff-rm[
```scala
*pred ⇓ `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
*pred ⇓ `true`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
*&#x200B;`pred ⇓ false`
*&#x200B;`⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯`
* `Cond pred onT onF ⇓ ???`
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

```scala
pred ⇓ `true`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
pred ⇓ `false`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

```scala
pred ⇓ `true`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
pred ⇓ false
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
*pred ⇓ true        `onT ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
&#x200B;
pred ⇓ false
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

.diff-rm[
```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred onT onF ⇓ `???`
&#x200B;
pred ⇓ false
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

.diff-add[
```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred onT onF ⇓ `v`
&#x200B;
pred ⇓ false
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ `false`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```


```ocaml
if true then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
*pred ⇓ false       `onF ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ ???
```
]

```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

.diff-rm[
```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred onT onF ⇓ `???`
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

.diff-add[
```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
* Cond pred onT onF ⇓ `v`
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```
---

```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* `case Cond()`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond` pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond` pred onT onF ⇓ v
```
---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(`pred: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond `pred` onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond `pred` onT onF ⇓ v
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(pred: Expr`, onT: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred `onT` onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred `onT` onF ⇓ v
```
---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(pred: Expr, onT: Expr`, onF: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT `onF` ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT `onF` ⇓ v
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
import Expr.*
```

---

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```
---

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
* `case Cond(pred, onT, onF) => cond(pred, onT, onF)`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond pred onT onF` ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond pred onT onF` ⇓ v
```

---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* `if interpret(pred) then`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`pred ⇓ true`        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```
---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* if interpret(pred) then` interpret(onT)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        `onT ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ `v`
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
* `else                    interpret(onF)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       `onF ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ `v`
```
---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if `interpret(pred)` then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* if interpret(pred) `!= 0` then interpret(onT)
* else               `    `      interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

.diff-rm[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* if interpret(pred) `!= 0` then interpret(onT)
* else               `    `      interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```
---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

```scala
def interpret(expr: Expr): `Int` = expr match
  case Num(value)           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  Cond pred onT onF ⇓ v
```

---

```scala
enum Value:
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
enum Value:
* `case Num(value: Int)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
enum Value:
  case Num(value: Int)
* `case Bool(value: Boolean)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala repl:invisible
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)

def interpret(expr: Expr): Value = ???

def typeError(label: String) = sys.error(s"Type error in $label")
```

---

.diff-rm[
```scala
*def interpret(expr: Expr): `Int` = expr match
  case Num(value)           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
*def interpret(expr: Expr): `Value` = expr match
  case Num(value)           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```
]

---

```scala
def interpret(expr: Expr): Value = expr match
  case `Num(value)`           => value
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;`Num value` ⇓ value
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-rm[
```scala
def interpret(expr: Expr): Value = expr match
* case Num(value)           => `value`
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```
]

.diff-rm[
```scala
&#x200B;
&#x200B;
*Num value ⇓ `value`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
* case Num(value)           => `Value.Num(value)`
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
&#x200B;
&#x200B;
*Num value ⇓ `Value.Num value`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

```scala
lhs ⇓ v₁      rhs ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Add lhs rhs` ⇓ v₁ + v₂
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

.diff-rm[
```scala
*lhs ⇓ `v₁`      rhs ⇓ `v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ v₁ + v₂
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

.diff-add[
```scala
*lhs ⇓ `Value.Num v₁`      rhs ⇓ `Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        Add lhs rhs ⇓ v₁ + v₂
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

.diff-rm[
```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*       Add lhs rhs ⇓ `v₁ + v₂`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

.diff-add[
```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*   Add lhs rhs ⇓ `Value.Num (v₁ + v₂)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

```scala
def add(lhs: Expr, rhs: Expr) =
  val v1 = interpret(lhs)
  val v2 = interpret(rhs)
&#x200B;
  v1 + v2
&#x200B;
```

```scala
lhs ⇓ `Value.Num v₁`      rhs ⇓ `Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-rm[
```scala
def add(lhs: Expr, rhs: Expr) =
* `val v1 = interpret(lhs)`
* `val v2 = interpret(rhs)`
*&#x200B;
* `v1 + v2`
&#x200B;
```
]

```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
* `(interpret(lhs), interpret(rhs)) match`
*   `case (Value.Num(v1), Value.Num(v2)) =>`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs ⇓ Value.Num v₁`      `rhs ⇓ Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```scala
def add(lhs: Expr, rhs: Expr) =
  (`interpret(lhs)`, interpret(rhs)) match
    case (`Value.Num(v1)`, Value.Num(v2)) =>
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`lhs ⇓ Value.Num v₁`      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), `interpret(rhs)`) match
    case (Value.Num(v1), `Value.Num(v2)`) =>
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs ⇓ Value.Num v₁      `rhs ⇓ Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
*   case (Value.Num(v1), Value.Num(v2)) => `Value.Num(v1 + v2)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ `Value.Num (v₁ + v₂)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
*   `case _                              =>`
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```


---

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
*   case _                              => `typeError("add")`
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num v₁      rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Add lhs rhs ⇓ Value.Num (v₁ + v₂)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala repl:invisible
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")
```

---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond pred onT onF` ⇓ v
&#x200B;
pred ⇓ false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
  `Cond pred onT onF` ⇓ v
```

---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
*pred ⇓ `Value.Bool` true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
*pred ⇓ `Value.Bool` false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```
]

---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ Value.Bool true        onT ⇓ `v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ `v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

---

```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  if interpret(pred) then interpret(onT)
  else                    interpret(onF)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ `v`
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ `v`
```

---

.diff-rm[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* `if interpret(pred) then interpret(onT)`
* `else                    interpret(onF)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
* `interpret(pred) match`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`pred` ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
&#x200B;`pred` ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```
---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
*   `case Value.Bool(true)  =>`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ `Value.Bool true`        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
*   case Value.Bool(true)  => `interpret(onT)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        `onT ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ `v`
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```
---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(onT)
*   `case Value.Bool(false) =>`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ `Value.Bool false`       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(onT)
*   case Value.Bool(false) => `interpret(onF)`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       `onF ⇓ v`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ `v`
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(onT)
    case Value.Bool(false) => interpret(onF)
*   `case _                 =>`
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

---

.diff-add[
```scala
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(onT)
    case Value.Bool(false) => interpret(onF)
*   case _                 => `typeError("cond")`
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true        onT ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
&#x200B;
pred ⇓ Value.Bool false       onF ⇓ v
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
       Cond pred onT onF ⇓ v
```

```scala repl:invisible
def cond(pred: Expr, onT: Expr, onF: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(onT)
    case Value.Bool(false) => interpret(onF)
    case _                 => typeError("cond")
```

---

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
if `true` then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
if `true` then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;`Bool` ⇓ ???
```

---

```ocaml
if `true` then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
&#x200B;
*Bool `value` ⇓ ???
```
]

---

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-rm[
```scala
&#x200B;
&#x200B;
*Bool value ⇓ `???`
```
]

---

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
&#x200B;
*Bool value ⇓ `Value.Bool value`
```
]

---

```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
Bool value ⇓ Value.Bool value
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* `case Bool()`
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;`Bool` value ⇓ Value.Bool value
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Bool(`value: Boolean`)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
Bool `value` ⇓ Value.Bool value
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
import Expr.*
```

---

```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)           => Value.Num(value)
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
Bool value ⇓ Value.Bool value
```

---

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)           => Value.Num(value)
* `case Bool(value)          =>`
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;`Bool value` ⇓ Value.Bool value
```

---

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)           => Value.Num(value)
* case Bool(value)          => `Value.Bool(value)`
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
Bool value ⇓ `Value.Bool value`
```

```scala repl:invisible
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")

def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(t)
    case Value.Bool(false) => interpret(e)
    case _                 => typeError("cond")

def interpret(expr: Expr): Value = expr match
  case Num(value)           => Value.Num(value)
  case Bool(value)          => Value.Bool(value)
  case Add(lhs, rhs)        => add(lhs, rhs)
  case Cond(pred, onT, onF) => cond(pred, onT, onF)
```

---

```ocaml
if true then 1
        else 2
```

```scala
val expr = Cond(
  pred = Bool(true),
  onT  = Num(1),
  onF  = Num(2)
)
```

```scala
interpret(expr)
```

---

```ocaml
&#x200B;`if` true then 1
        else 2
```

```scala
val expr = `Cond`(
  pred = Bool(true),
  onT  = Num(1),
  onF  = Num(2)
)
```

```scala
interpret(expr)
```

---

```ocaml
if `true` then 1
        else 2
```

```scala
val expr = Cond(
  pred = `Bool(true)`,
  onT  = Num(1),
  onF  = Num(2)
)
```
```scala
interpret(expr)
```

---

```ocaml
if true `then 1`
        else 2
```

```scala
val expr = Cond(
  pred = Bool(true),
  onT  = `Num(1)`,
  onF  = Num(2)
)
```

```scala
interpret(expr)
```

---

```ocaml
if true then 1
        `else 2`
```

```scala
val expr = Cond(
  pred = Bool(true),
  onT  = Num(1),
  onF  = `Num(2)`
)
```

```scala
interpret(expr)
```

---

```ocaml
if true then 1
        else 2
```

```scala repl
val expr = Cond(
  pred = Bool(true),
  onT  = Num(1),
  onF  = Num(2)
)
```

```scala repl
interpret(expr)
```
---

## [Key takeaways](#conclusion)

--

* Conditionals are straightforward to support

--

* They forced us to support multiple types of values

--

* Friends don't let friends implement truthiness

---

class: center, middle
name: bindings

# Naming things

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1
&#x200B;
x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`let` x = 1
&#x200B;
x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
x
&#x200B;
let x = 1
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 `in`
  x + 2
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  x + 2
&#x200B;
```

---

.diff-add[
```ocaml
*&#x200B;`x = 1`
&#x200B;
```
]

<hr/>

```ocaml
let `x = 1` in
  x + 2
&#x200B;
```

---

```ocaml
x = 1
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  `x + 2`
&#x200B;
```

---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
  `x` + 2
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `1` + 2
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `1 + 2`
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `3`
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let x = 1 in`
* `3`
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3`
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 + 2 in
  if true then 1
  else         x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1 + 2` in
  if true then 1
  else         x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 + 2 in
  if `true` then 1
  else         x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 + 2 in
  if true then `1`
  else         x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 + 2 in
  if true then 1
  else         `x`
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*let x = `1 + 2` in
  if true then 1
  else         x
```
]

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*let x = `3` in
  if true then 1
  else         x
```
]

---

```ocaml
&#x200B;
&#x200B;
```


<hr/>

```ocaml
let `x = 3` in
  if true then 1
  else         x
```

---

.diff-add[
```ocaml
*&#x200B;`x = 3`
&#x200B;
```
]

<hr/>

```ocaml
let `x = 3` in
  if true then 1
  else         x
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + (let x = 2 in x)
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  x + (let x = 2 in x)
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  `x` + (let x = 2 in x)
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + (let `x = 2` in x)
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + (let x = 2 in `x`)
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `x` + `(let x = 2 in x)`
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `(let x = 2 in x)` + `x`
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  (let x = 2 in x) + x
&#x200B;
```

---

.diff-add[
```ocaml
&#x200B;`x = 1`
&#x200B;
```
]

<hr/>

```ocaml
let x = 1 in
  `(let x = 2 in x) + x`
&#x200B;
```

---

```ocaml
x = 1
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

.diff-rm[
```ocaml
*x = `1`
&#x200B;
```
]

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

.diff-add[
```ocaml
*x = `2`
&#x200B;
```
]

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

```ocaml
&#x200B;`x = 2`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* (let x = 2 in `x`) + x
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 2`
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* (let x = 2 in `2`) + x
&#x200B;
```
]

---

```ocaml
x = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `(let x = 2 in 2)` + x
&#x200B;
```
]

---

```ocaml
x = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `2` + x
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 2`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* 2 + `x`
&#x200B;
```
]

---

```ocaml
x = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* 2 + `2`
&#x200B;
```
]

---

```ocaml
x = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `2 + 2`
&#x200B;
```
]

---

```ocaml
x = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `4`
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

.diff-add[
```ocaml
x = 1
&#x200B;`x = 2`
```
]

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

```ocaml
x = 1
&#x200B;`x = 2`
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* (let x = 2 in `x`) + x
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;`x = 2`
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* (let x = 2 in `2`) + x
&#x200B;
```
]

---

.diff-rm[
```ocaml
x = 1
*&#x200B;`x = 2`
```
]

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `(let x = 2 in 2)` + x
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `2` + x
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* 2 + `x`
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
  2 + `1`
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
  `2 + 1`
&#x200B;
```
]
---

```ocaml
&#x200B;`x = 1`
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
  `3`
&#x200B;
```
]

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
            `Let` ⇓ ???
```

```ocaml
&#x200B;`let` x = 1 in
  x + 2
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*           Let `name` ⇓ ???
```
]

```ocaml
let `x` = 1 in
  x + 2
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*           Let name `value` ⇓ ???
```
]

```ocaml
let x = `1` in
  x + 2
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*           Let name value `body` ⇓ ???
```
]

```ocaml
let x = 1 in
  `x + 2`
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
            Let name `value` body ⇓ ???
```

```ocaml
let x = `1` in
  x + 2
```

---

.diff-add[
```scala
*&#x200B;`value ⇓ v₁`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
            Let name value body ⇓ ???
```
]

```ocaml
let x = `1` in
  x + 2
```

---

```scala
value ⇓ v₁
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
            Let name value `body` ⇓ ???
```

```ocaml
let x = 1 in
  `x + 2`
```

---

.diff-add[
```scala
*&#x200B;`e |-` value ⇓ v₁
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*         `e |-` Let name value body ⇓ ???
```
]

```ocaml
let x = 1 in
  x + 2
```

---

```scala
&#x200B;`e |- value ⇓ v₁`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
          e |- Let name value body ⇓ ???
```

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
*e |- value ⇓ v₁                    `??? |- body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
          e |- Let name value body ⇓ ???
```
]

```ocaml
let x = 1 in
  `x + 2`
```

---

.diff-rm[
```scala
e |- value ⇓ v₁                    `???` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
          e |- Let name value body ⇓ ???
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
*e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
          e |- Let name value body ⇓ ???
```
]

```ocaml
let `x = 1` in
  x + 2
```

---

.diff-rm[
```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*         e |- Let name value body ⇓ `???`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*         e |- Let name value body ⇓ `v₂`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

```scala
&#x200B;
&#x200B;
e |- `Ref` ⇓ ???
```

```ocaml
let x = 1 in
  `x` + 2
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
*e |- Ref `name` ⇓ ???
```
]

```ocaml
let x = 1 in
  `x` + 2
```

---

.diff-rm[
```scala
&#x200B;
&#x200B;
*&#x200B;e |- Ref name ⇓ `???`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
*&#x200B;e |- Ref name ⇓ `lookup(e, name)`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- `Let name value body` ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
* `case Let()`
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- `Let` name value body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
* case Let(`name: String`)
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let `name` value body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
* case Let(name: String`, value: Expr`)
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name `value` body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
* case Let(name: String, value: Expr`, body: Expr`)
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value `body` ⇓ v₂
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
&#x200B;
```

```scala
&#x200B;
&#x200B;
e |- `Ref name` ⇓ lookup(e, name)
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* `case Ref()`
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
e |- `Ref` name ⇓ lookup(e, name)
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case Ref(`name: String`)
```
]

```scala
&#x200B;
&#x200B;
e |- Ref `name` ⇓ lookup(e, name)
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(`name: String`, value: Expr, body: Expr)
  case Ref(`name: String`)
```

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ lookup(e, name)
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
```

```scala
&#x200B;
&#x200B;
&#x200B;`e` |- Ref name ⇓ lookup(e, name)
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
import Expr.*
```

---

```scala
case class Env():
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
*case class Env(`env: List[Env.Binding]`):
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
&#x200B;
*&#x200B;`object Env:`
* `case class Binding()`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
&#x200B;
object Env:
* case class Binding(`name: String`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
&#x200B;
object Env:
* case class Binding(name: String`, value: Value`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
* `def lookup(name: String) =`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ `lookup(e, name)`
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
*   `env.find(_.name == name)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ `lookup(e, name)`
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
*      `.map(_.value)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ `lookup(e, name)`
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
*      `.getOrElse(sys.error(s"Unbound variable: $name"))`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ `lookup(e, name)`
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
*&#x200B;
* `def bind(name: String, value: Value) =`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
*   `Env.Binding(name, value)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
*   Env.Binding(name, value)` :: env`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
*   `Env(`Env.Binding(name, value) :: env`)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
*&#x200B;
* `val empty = Env(List.empty)`
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

```scala repl:invisible
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)

object Env:
  case class Binding(name: String, value: Value)

  val empty = Env(List.empty)
```

---

```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
*def interpret(expr: Expr, `e: Env`): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
* case Add(lhs, rhs)          => add(lhs, rhs`, e`)
* case Cond(pred, onT, onF)   => cond(pred, onT, onF`, e`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
* `case Let(name, value, body) => let(name, value, body, e)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
* `val v1 = interpret(value, e)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`e |- value ⇓ v₁`      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
* `val v2 = interpret(body, ???)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- `body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-rm[
```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
* val v2 = interpret(body, `???`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
* val v2 = interpret(body, `e.bind(name, v1)`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      `bind(e, name, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ v₂
```

---

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
  val v2 = interpret(body, e.bind(name, v1))
&#x200B;
* `v2`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- value ⇓ v₁      bind(e, name, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         e |- Let name value body ⇓ `v₂`
```

---

```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
e |- `Ref name` ⇓ lookup(e, name)
```

---

.diff-add[
```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
* `case Ref(name)              =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- `Ref name` ⇓ lookup(e, name)
```
---

.diff-add[
```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
* case Ref(name)              => `e.lookup(name)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
e |- Ref name ⇓ `lookup(e, name)`
```

```scala repl:invisible
def add(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")

def cond(pred: Expr, onT: Expr, onF: Expr, e: Env) =
  interpret(pred, e) match
    case Value.Bool(true)  => interpret(onT, e)
    case Value.Bool(false) => interpret(onF, e)
    case _                 => typeError("cond")

def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
  val v2 = interpret(body, e.bind(name, v1))

  v2

def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
```

---

```ocaml
let x = 1 in
  (let x = 2 in x) + x
```

```scala
val expr = Let(
  // ...
)
```


```scala
interpret(expr, Env.empty)
```

---

```ocaml
let x = 1 in
  (let x = 2 in x) + x
```

```scala
val expr = Let(
  // ...
)
```

```scala repl:invisible
val expr = Let(
  name  = "x",
  value = Num(1),
  body  = Add(
    Let(
      name  = "x",
      value = Num(2),
      body  = Ref("x")
    ),
    Ref("x")))
```

```scala repl
interpret(expr, Env.empty)
```

---

## [Key takeaways](#conclusion)

--

* Local bindings have a scope that can be analyzed statically

--

* They can shadowed, but not overwritten

--

* Their interpretation requires an environment

---

class: center, middle
name: functions

# Reusing Code

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + 2
  &#x200B;
  &#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  `x + 2`
  &#x200B;
  &#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  x + 2
  &#x200B;
  &#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let x = 1 in`
* `x + 2`
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`(x -> x + 2) 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`(x -> x + 2)` 1
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
(x -> x + 2) `1`
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`(x -> x + 2) 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```ocaml
*&#x200B;`x = 1`
&#x200B;
&#x200B;
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + 2
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;`x = 1`
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`1` + 2
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`1 + 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3`
&#x200B;
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let f = x -> x + 2 in
  f 1
&#x200B;
&#x200B;
```
]

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f = `x -> x + 2` in
  f 1
&#x200B;
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `f` = x -> x + 2 in
  f 1
&#x200B;
&#x200B;
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f = x -> x + 2 in
  `f 1`
&#x200B;
&#x200B;
```

---

```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
&#x200B;
```

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* `case Fun()`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(`param: String`)
```
]

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(param: String`, body: Expr`)
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      `f 3`
```

---

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

.diff-add[
```ocaml
*&#x200B;`y = 1`
&#x200B;
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

```ocaml
y = 1
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```

---

.diff-add[
```ocaml
y = 1
*&#x200B;`f = x -> x + y`
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```

---

```ocaml
y = 1
f = x -> x + y
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let `y = 2` in
      f 3
```

---

.diff-add[
```ocaml
y = 1
f = x -> x + y
*&#x200B;`y = 2`
&#x200B;
```
]

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let `y = 2` in
      f 3
```

---

```ocaml
y = 1
f = x -> x + y
y = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `f 3`
```
]

---

.diff-add[
```ocaml
y = 1
f = x -> x + y
y = 2
*&#x200B;`x = 3`
```
]

<hr/>

.diff-add[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `x + y`
```
]

---

.diff-rm[
```ocaml
y = 1
f = x -> x + y
y = 2
*&#x200B;`x = 3`
```
]

<hr/>

.diff-rm[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `x` + y
```
]

---

```ocaml
y = 1
f = x -> x + y
y = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `3` + y
```
]

---

```ocaml
y = 1
f = x -> x + y
&#x200B;`y = 2`
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     3 + `y`
```
]

---

```ocaml
y = 1
f = x -> x + y
&#x200B;`y = 2`
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     3 + `2`
```
]

---

```ocaml
y = 1
f = x -> x + y
y = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `3 + 2`
```
]

---

```ocaml
y = 1
f = x -> x + y
y = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
*     `5`
```
]

---

```ocaml
y = 1
f = x -> x + y
y = 2
x = 3
```

<hr/>

.diff-add[
```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```
]

---

```ocaml
&#x200B;`y = 1`
f = x -> x + y
y = 2
x = 3
```

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

```ocaml
y = 1
&#x200B;`f = x -> x + y`
y = 2
x = 3
```

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```

---

```ocaml
y = 1
f = x -> x + y
&#x200B;`y = 2`
x = 3
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let `y = 2` in
      f 3
```

---

```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr)
```

---

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(param: String, body: Expr`, env: Env`)
```
]

```scala repl:invisible
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr, env: Env)
```

---

```scala
&#x200B;
&#x200B;
&#x200B;
e |- `Fun` ⇓ ???
```

```ocaml
let `f = x -> x + 2` in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun `param` ⇓ ???
```
]

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param `body` ⇓ ???
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

.diff-rm[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param body ⇓ `???`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param body ⇓ `Value.Fun`
```
]

```ocaml
let f = `x -> x + 2` in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param body ⇓ Value.Fun `param`
```
]

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param body ⇓ Value.Fun param `body`
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
&#x200B;
*e |- Fun param body ⇓ Value.Fun param body `e`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply ⇓ ???
```

```ocaml
let f = x -> x + 2 in
  `f 1`
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply `fun` ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun `arg` ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f `1`
```

---

.diff-add[
```scala
*&#x200B;`e |- fun ⇓ ???`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

.diff-rm[
```scala
*e |- fun ⇓ `???`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

.diff-add[
```scala
*e |- fun ⇓ `Value.Fun param body eʹ`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

.diff-add[
```scala
*e |- fun ⇓ Value.Fun param body eʹ      `e |- arg ⇓ v₁`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f `1`
```

---

.diff-add[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
*&#x200B;`??? |- body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

.diff-rm[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
*&#x200B;`???` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
*&#x200B;`eʹ` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

```scala
e |- fun ⇓ Value.Fun `param` body eʹ      e |- arg ⇓ v₁
eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ `v₁`
eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```

```ocaml
let f = x -> x + 2 in
  f `1`
```

---

.diff-rm[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
*&#x200B;`eʹ` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
*&#x200B;`bind(eʹ, param, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-rm[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*            e |- Apply fun arg ⇓ `???`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

.diff-add[
```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*            e |- Apply fun arg ⇓ `v₂`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
e |- `Fun param body` ⇓ Value.Fun param body e
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
* `case Fun()`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
e |- `Fun` param body ⇓ Value.Fun param body e
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
* case Fun(`param: String`)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
e |- Fun `param` body ⇓ Value.Fun param body e
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
* case Fun(param: String`, body: Expr`)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
e |- Fun param `body` ⇓ Value.Fun param body e
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
&#x200B;
```

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- `Apply fun arg` ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
* `case Apply()`
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- `Apply` fun arg ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
* case Apply(`fun: Expr`)
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply `fun` arg ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
* case Apply(fun: Expr`, arg: Expr`)
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun `arg` ⇓ v₂
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
import Expr.*
```

---

```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
e |- `Fun param body` ⇓ Value.Fun param body e
```

---

.diff-add[
```scala
def interpret(expr: Expr, Γ: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, Γ)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, Γ)
  case Let(name, value, body) => let(name, value, body, Γ)
  case Ref(name)              => Γ.lookup(name)
* `case Fun(param, body)       => Value.Fun(param, body, Γ)`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
e |- Fun param body ⇓ `Value.Fun param body e`
```

---

```scala
def interpret(expr: Expr, Γ: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, Γ)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, Γ)
  case Let(name, value, body) => let(name, value, body, Γ)
  case Ref(name)              => Γ.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, `Γ`)
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
e |- Fun param body ⇓ `Value.Fun param body e`
```

---

```scala
def interpret(expr: Expr, Γ: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, Γ)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, Γ)
  case Let(name, value, body) => let(name, value, body, Γ)
  case Ref(name)              => Γ.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, Γ)
&#x200B;
```

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- `Apply fun arg` ⇓ v₂
```

---

.diff-add[
```scala
def interpret(expr: Expr, Γ: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, Γ)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, Γ)
  case Let(name, value, body) => let(name, value, body, Γ)
  case Ref(name)              => Γ.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, Γ)
* `case Apply(fun, arg)        => apply(fun, arg, Γ)`
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
* `interpret(fun, Γ) match`
*   `case Value.Fun(param, body, Γʹ) =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`e |- fun ⇓ Value.Fun param body eʹ`      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
  interpret(fun, Γ) match
    case Value.Fun(param, body, Γʹ) =>
*     `val v1 = interpret(arg, Γ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      `e |- arg ⇓ v₁`
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
  interpret(fun, Γ) match
    case Value.Fun(param, body, Γʹ) =>
      val v1 = interpret(arg, Γ)
*     `val v2 = interpret(body, ???)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- `body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-rm[
```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
  interpret(fun, Γ) match
    case Value.Fun(param, body, Γʹ) =>
      val v1 = interpret(arg, Γ)
*     val v2 = interpret(body, `???`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
&#x200B;`bind(eʹ, param, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, Γ: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, Γʹ) =>
      val v1 = interpret(arg, Γ)
*     val v2 = interpret(body, `Γʹ.bind(param, v1)`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
&#x200B;`bind(eʹ, param, v₁)` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, e: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, eʹ) =>
      val v1 = interpret(arg, e)
      val v2 = interpret(body, eʹ.bind(param, v1))
&#x200B;
*     `v2`
&#x200B;
&#x200B;
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ `v₂`
```

---

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, e: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, eʹ) =>
      val v1 = interpret(arg, e)
      val v2 = interpret(body, eʹ.bind(param, v1))
&#x200B;
      v2
&#x200B;
*   `case _ => typeError("apply")`
```
]

```scala
e |- fun ⇓ Value.Fun param body eʹ      e |- arg ⇓ v₁
bind(eʹ, param, v₁) |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
             e |- Apply fun arg ⇓ v₂
```

```scala repl:invisible
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr, env: Env)

case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
        .map(_.value)
        .getOrElse(sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)

object Env:
  case class Binding(name: String, value: Value)

  val empty = Env(List.empty)

def add(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")

def cond(pred: Expr, onT: Expr, onF: Expr, e: Env) =
  interpret(pred, e) match
    case Value.Bool(true)  => interpret(onT, e)
    case Value.Bool(false) => interpret(onF, e)
    case _                 => typeError("cond")

def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
  val v2 = interpret(body, e.bind(name, v1))

  v2

def apply(fun: Expr, arg: Expr, e: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, eʹ) =>
      val argValue  = interpret(arg, e)
      val functionEnv = eʹ.bind(param, argValue)

      interpret(body, functionEnv)

    case _ =>
      typeError("apply")

def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Fun(param, body)  => Value.Fun(param, body, e)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
  case Apply(fun, arg)   => apply(fun, arg, e)
```

---

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

```scala
val expr = Let(
  // ...
)
```

```scala repl:invisible
val expr = Let(
  name  = "y",
  value = Num(1),
  body = Let(
    name = "f",
    value = Fun(
      param = "x",
      body  = Add(Ref("x"), Ref("y"))),
    body = Let(
      name = "y",
      value = Num(2),
      body = Apply(Ref("f"), Num(3)))))
```

```scala repl
interpret(expr, Env.empty)
```

---

```ocaml
let add = ??? in
  add 1 2
&#x200B;
&#x200B;
```

```scala
val expr = ???
&#x200B;
&#x200B;
```

```scala
interpret(expr, Env.empty)
```

---

.diff-rm[
```ocaml
*let add = `???` in
  add 1 2
&#x200B;
&#x200B;
```
]

```scala
val expr = ???
&#x200B;
&#x200B;
```

```scala
interpret(expr, Env.empty)
```

---

.diff-add[
```ocaml
*let add = `x -> ???` in
  add 1 2
&#x200B;
&#x200B;
```
]

```scala
val expr = ???
&#x200B;
&#x200B;
```

```scala
interpret(expr, Env.empty)
```

---

.diff-rm[
```ocaml
*let add = x -> `???` in
  add 1 2
&#x200B;
&#x200B;
```
]

```scala
val expr = ???
&#x200B;
&#x200B;
```

```scala
interpret(expr, Env.empty)
```

---

.diff-add[
```ocaml
*let add = x -> `y -> x + y` in
  add 1 2
&#x200B;
&#x200B;
```
]

```scala
val expr = ???
&#x200B;
&#x200B;
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
let add = x -> y -> x + y in
  add 1 2
&#x200B;
&#x200B;
```

.diff-rm[
```scala
*val expr = `???`
&#x200B;
&#x200B;
```
]

```scala
interpret(expr, Env.empty)
```

---

```ocaml
let add = x -> y -> x + y in
  add 1 2
&#x200B;
&#x200B;
```

.diff-add[
```scala
*val expr = `Let(`
* `// ...`
*&#x200B;`)`
```
]

```scala
interpret(expr, Env.empty)
```

---

```ocaml
let add = x -> y -> x + y in
  add 1 2
&#x200B;
&#x200B;
```

```scala
val expr = Let(
  // ...
)
```

```scala repl:invisible
val expr = Let(
  name  = "add",
  value = Fun(
    param = "x",
    body  = Fun(
      param = "y",
      body  = Add(Ref("x"), Ref("y")))),
  body = Apply(
    fun = Apply(
      fun = Ref("add"),
      arg  = Num(1)),
    arg = Num(2)))
```

```scala repl
interpret(expr, Env.empty)
```

---

## [Key takeaways](#conclusion)

--

* Functions are values

--

* They _close_ over their environment

--

* Yes, unary functions are sufficient

---

class: center, middle
name: recursion

# Repeating actions

---

```ocaml
let `sumFor` = lower -> upper ->
    var acc = 0
    for i = lower to upper do
      acc = acc + i
    acc
  in sumFor 1 10
&#x200B;
&#x200B;
```


---

```ocaml
let sumFor = `lower -> upper` ->
    var acc = 0
    for i = lower to upper do
      acc = acc + i
    acc
  in sumFor 1 10
&#x200B;
&#x200B;
```

---

```ocaml
let sumFor = lower -> upper ->
    `var acc = 0`
    for i = lower to upper do
      acc = acc + i
    acc
  in sumFor 1 10
&#x200B;
&#x200B;
```

---

```ocaml
let sumFor = lower -> upper ->
    var acc = 0
    `for i = lower to upper do`
      acc = acc + i
    acc
  in sumFor 1 10
&#x200B;
&#x200B;
```

---

```ocaml
let sumFor = lower -> upper ->
    var acc = 0
    for i = lower to upper do
      `acc = acc + i`
    acc
  in sumFor 1 10
&#x200B;
&#x200B;
```

---

```ocaml
let sumFor = lower -> upper ->
    var acc = 0
    for i = lower to upper do
      acc = acc + i
    `acc`
  in sumFor 1 10
&#x200B;
&#x200B;
```

---

.diff-rm[
```ocaml
*let `sumFor` = lower -> upper ->
    var acc = 0
    for i = lower to upper do
      acc = acc + i
    acc
* in `sumFor` 1 10
&#x200B;
&#x200B;
```
]

---

.diff-add[
```ocaml
*let `sumWhile` = lower -> upper ->
    var acc = 0
    for i = lower to upper do
      acc = acc + i
    acc
* in `sumWhile` 1 10
&#x200B;
&#x200B;
```
]

---

```ocaml
let sumWhile = lower -> upper ->
    var acc = 0
    for `i = lower to upper` do
      acc = acc + i
    acc
  in sumWhile 1 10
&#x200B;
&#x200B;
```

---

.diff-add[
```ocaml
let sumWhile = lower -> upper ->
    var acc = 0
*   `var i   = lower`
    for i = lower to upper do
      acc = acc + i
    acc
  in sumWhile 1 10
&#x200B;
```
]

---

.diff-add[
```ocaml
let sumWhile = lower -> upper ->
    var acc = 0
    var i   = lower
    for i = lower to upper do
      acc = acc + i
*     `i   = i + 1`
    acc
  in sumWhile 1 10
```
]

---

.diff-rm[
```ocaml
let sumWhile = lower -> upper ->
    var acc = 0
    var i   = lower
*   `for i = lower to upper do`
      acc = acc + i
      i   = i + 1
    acc
  in sumWhile 1 10
```
]

---

.diff-add[
```ocaml
let sumWhile = lower -> upper ->
    var acc = 0
    var i   = lower
*   `while i < upper do`
      acc = acc + i
      i   = i + 1
    acc
  in sumWhile 1 10
```
]

---

.diff-rm[
```ocaml
*let `sumWhile` = lower -> upper ->
    var acc = 0
    var i   = lower
    while i < upper do
      acc = acc + i
      i   = i + 1
    acc
* in `sumWhile` 1 10
```
]

---

.diff-add[
```ocaml
*let `sumRec` = lower -> upper ->
    var acc = 0
    var i   = lower
    while i < upper do
      acc = acc + i
      i   = i + 1
    acc
* in `sumRec` 1 10
```
]

---

```ocaml
let sumRec = lower -> upper ->
    var `acc` = 0
    var `i`   = lower
    while i < upper do
      acc = acc + i
      i   = i + 1
    acc
  in sumRec 1 10
```

---

.diff-rm[
```ocaml
let sumRec = lower -> upper ->
*   `var acc = 0`
*   `var i   = lower`
    while i < upper do
      acc = acc + i
      i   = i + 1
    acc
  in sumRec 1 10
```
]

---

.diff-add[
```ocaml
let sumRec = lower -> upper ->
*   `let go = acc -> i ->`
      while i < upper do
        acc = acc + i
        i   = i + 1
      acc
*   `in go 0 lower`
  in sumRec 1 10
```
]

---

.diff-rm[
```ocaml
let sumRec = lower -> upper ->
    let go = acc -> i ->
*     `while i < upper do`
*       `acc = acc + i`
*       `i   = i + 1`
      acc
    in go 0 lower
  in sumRec 1 10
```
]

---

.diff-add[
```ocaml
let sumRec = lower -> upper ->
    let go = acc -> i ->
*     `if i < upper then go (acc + i) (i + 1)`
      acc
    in go 0 lower
  in sumRec 1 10
&#x200B;
&#x200B;
```
]

---

.diff-rm[
```ocaml
let sumRec = lower -> upper ->
    let go = acc -> i ->
      if i < upper then go (acc + i) (i + 1)
*     `acc`
    in go 0 lower
  in sumRec 1 10
&#x200B;
&#x200B;
```
]

---

.diff-add[
```ocaml
let sumRec = lower -> upper ->
    let go = acc -> i ->
      if i < upper then go (acc + i) (i + 1)
*     `else acc`
    in go 0 lower
  in sumRec 1 10
&#x200B;
&#x200B;
```
]

---

.diff-rm[
```ocaml
*let `sumRec` = lower -> upper ->
    let go = acc -> i ->
      if i < upper then go (acc + i) (i + 1)
      else acc
    in go 0 lower
* in `sumRec` 1 10
&#x200B;
&#x200B;
```
]

---

.diff-add[
```ocaml
*let `sum` = lower -> upper ->
    let go = acc -> i ->
      if i < upper then go (acc + i) (i + 1)
      else acc
    in go 0 lower
* in `sum` 1 10
&#x200B;
&#x200B;
```
]

---

.diff-rm[
```ocaml
let sum = lower -> upper ->
*   `let go = acc -> i ->`
*     `if i < upper then go (acc + i) (i + 1)`
*     `else acc`
*   `in go 0 lower`
  in sum 1 10
&#x200B;
&#x200B;
```
]

---

.diff-add[
```ocaml
let sum = lower -> upper ->
*   `if lower > upper then 0`
*   `else lower + (sum (lower + 1) upper)`
  in sum 1 10
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]


---

```ocaml
let sum = lower -> upper ->
    `if lower > upper then 0`
    else lower + (sum (lower + 1) upper)
  in sum 1 10
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else `lower` + (sum (lower + 1) upper)
  in sum 1 10
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + `(sum (lower + 1) upper)`
  in sum 1 10
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```ocaml
let sum = lower -> upper ->
    if lower `>` upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt ⇓ ???
```

```ocaml
if 1 `>` 2 then false
         else true
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*       e |- Gt `lhs` ⇓ ???
```
]

```ocaml
if `1` > 2 then false
         else true
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*       e |- Gt lhs `rhs` ⇓ ???
```
]

```ocaml
if 1 > `2` then false
         else true
```

---

.diff-add[
```scala
*&#x200B;`e |- lhs ⇓ Value.Num v₁`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ ???
```
]

```ocaml
if `1` > 2 then false
         else true
```

---

.diff-add[
```scala
*e |- lhs ⇓ Value.Num v₁      `e |- rhs ⇓ Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ ???
```
]

```ocaml
if 1 > `2` then false
         else true
```

---

.diff-rm[
```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*       e |- Gt lhs rhs ⇓ `???`
```
]

```ocaml
if `1 > 2` then false
         else true
```

---

.diff-add[
```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*       e |- Gt lhs rhs ⇓ `Value.Bool (v₁ > v₂)`
```
]

```ocaml
if `1 > 2` then false
         else true
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
```

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- `Gt lhs rhs` ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* `case Gt()`
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- `Gt` lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* case Gt(`lhs: Expr`)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt `lhs` rhs ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* case Gt(lhs: Expr`, rhs: Expr`)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs `rhs` ⇓ Value.Bool (v₁ > v₂)
```

---

```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, e)
  case Apply(fun, arg)        => apply(fun, arg, e)
&#x200B;
```

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```


---

.diff-add[
```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
* `case Gt(lhs, rhs)           => gt(lhs, rhs, e)`
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, e)
  case Apply(fun, arg)        => apply(fun, arg, e)
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- `Gt lhs rhs` ⇓ Value.Bool (v₁ > v₂)
```

---

```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
* `(interpret(lhs, e), interpret(rhs, e)) match`
*   `case (Value.Num(v1), Value.Num(v2)) =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`e |- lhs ⇓ Value.Num v₁`      `e |- rhs ⇓ Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
  (`interpret(lhs, e)`, interpret(rhs, e)) match
    case (`Value.Num(v1)`, Value.Num(v2)) =>
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`e |- lhs ⇓ Value.Num v₁`      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), `interpret(rhs, e)`) match
    case (Value.Num(v1), `Value.Num(v2)`) =>
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
e |- lhs ⇓ Value.Num v₁      `e |- rhs ⇓ Value.Num v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
*   case (Value.Num(v1), Value.Num(v2)) => `Value.Bool(v1 > v2)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ `Value.Bool (v₁ > v₂)`
```

---

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Bool(v1 > v2)
*   `case _                              =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

---

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Bool(v1 > v2)
*   case _                              => `typeError("gt")`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
e |- lhs ⇓ Value.Num v₁      e |- rhs ⇓ Value.Num v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
        e |- Gt lhs rhs ⇓ Value.Bool (v₁ > v₂)
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
import Expr.*

enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr, env: Env)

case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
        .map(_.value)
        .getOrElse(sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)

object Env:
  case class Binding(name: String, value: Value)

  val empty = Env(List.empty)

def add(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")

def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(lhs), Value.Num(rhs)) => Value.Bool(lhs > rhs)
    case _                                => typeError("gt")

def cond(pred: Expr, onT: Expr, onF: Expr, e: Env) =
  interpret(pred, e) match
    case Value.Bool(true)  => interpret(onT, e)
    case Value.Bool(false) => interpret(onF, e)
    case _                 => typeError("cond")

def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
  val v2 = interpret(body, e.bind(name, v1))

  v2

def apply(fun: Expr, arg: Expr, e: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, closedEnv) =>
      val argValue  = interpret(arg, e)
      val functionEnv = closedEnv.bind(param, argValue)
      interpret(body, functionEnv)
    case other =>
      typeError("apply")

def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Fun(param, body)  => Value.Fun(param, body, e)
  case Add(lhs, rhs)          => add(lhs, rhs, e)
  case Gt(lhs, rhs)           => gt(lhs, rhs, e)
  case Cond(pred, onT, onF)   => cond(pred, onT, onF, e)
  case Let(name, value, body) => let(name, value, body, e)
  case Ref(name)              => e.lookup(name)
  case Apply(fun, arg)   => apply(fun, arg, e)
```

---

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala repl:invisible
val expr = Let(
  name  = "sum",
  value = Fun(
    param = "lower",
    body  = Fun(
      param = "upper",
      body  = Cond(
        pred       = Gt(Ref("lower"), Ref("upper")),
        onT = Num(0),
        onF = Add(
          lhs = Ref("lower"),
          rhs = Apply(
            fun = Apply(
              fun = Ref("sum"),
              arg = Add(Ref("lower"), Num(1))),
            arg    = Ref("upper")))))),
  body = Apply(Apply(Ref("sum"), Num(1)), Num(10)))
```

```scala
interpret(expr, Env.empty)
// ⛔ Unbound variable: sum
```

---

```ocaml
let `sum` = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
// ⛔ Unbound variable: sum
```

---

```ocaml
let sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
// ⛔ Unbound variable: sum
```

---

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (`sum` (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
// ⛔ Unbound variable: sum
```

---

```scala
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-rm[
```ocaml
&#x200B;`let` sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

---

```scala
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```ocaml
*&#x200B;`let rec` sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

---

```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, `body: Expr, env: Env`)
```

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

```scala
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- `LetRec` ⇓ ???
```

```ocaml
&#x200B;`let rec` sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*  e |- LetRec `name` ⇓ ???
```
]

```ocaml
let rec `sum` = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*  e |- LetRec name `value` ⇓ ???
```
]

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*  e |- LetRec name value `body` ⇓ ???
```
]

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-add[
```scala
*&#x200B;`e |- value ⇓ v₁`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

```scala
&#x200B;`e` |- value ⇓ v₁
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
*&#x200B;`eʹ = bind(e, name, ∅);` e |- value ⇓ v₁
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-rm[
```scala
*eʹ = bind(e, name, ∅); `e` |- value ⇓ v₁
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
*eʹ = bind(e, name, ∅); `eʹ` |- value ⇓ v₁
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = `lower -> upper ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
* `eʹ |- body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
  `eʹ` |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-add[
```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
* `update(eʹ, name, v₁);` eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ ???
```
]

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-rm[
```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
  update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*  e |- LetRec name value body ⇓ `???`
```
]

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-add[
```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
  update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*  e |- LetRec name value body ⇓ `v₂`
```
]

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
```

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- `LetRec name value body` ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* `case LetRec()`
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- `LetRec` name value body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case LetRec(`name: String`)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec `name` value body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case LetRec(name: String`, value: Expr`)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name `value` body ⇓ v₂
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case LetRec(name: String, value: Expr`, body: Expr`)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value `body` ⇓ v₂
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 `update(eʹ, name, v₁)`; eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
  val empty = Env(List.empty)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
*&#x200B;
* `def update(name: String, value: Value) =`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
  val empty = Env(List.empty)
&#x200B;
&#x200B;
```
]


---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
  def update(name: String, value: Value) =
*   `env.find(_.name == name)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
  val empty = Env(List.empty)
&#x200B;
```
]

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
  def update(name: String, value: Value) =
    env.find(_.name == name)
*      `.foreach(_.value = value)`
&#x200B;
object Env:
  case class Binding(name: String, value: Value)
&#x200B;
  val empty = Env(List.empty)
```
]

---

.diff-rm[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
  def update(name: String, value: Value) =
    env.find(_.name == name)
       .foreach(_.value = value)
&#x200B;
object Env:
* case class Binding(name: String, `value: Value`)
&#x200B;
  val empty = Env(List.empty)
```
]

---

.diff-add[
```scala
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)
&#x200B;
  def update(name: String, value: Value) =
    env.find(_.name == name)
       .foreach(_.value = value)
&#x200B;
object Env:
* case class Binding(name: String, `var value: Value`)
&#x200B;
  val empty = Env(List.empty)
```
]

```scala repl:invisible
case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.value)
       .getOrElse(sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)

  def update(name: String, value: Value) =
    env.find(_.name == name)
       .foreach(_.value = value)

object Env:
  case class Binding(name: String, var value: Value)

  val empty = Env(List.empty)
```

---

```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)                => Value.Num(value)
  case Bool(value)               => Value.Bool(value)
  case Add(lhs, rhs)             => add(lhs, rhs, e)
  case Gt(lhs, rhs)              => gt(lhs, rhs, e)
  case Cond(pred, onT, onF)      => cond(pred, onT, onF, e)
  case Let(name, value, body)    => let(name, value, body, e)
  case Ref(name)                 => e.lookup(name)
  case Fun(param, body)          => Value.Fun(param, body, e)
  case Apply(fun, arg)           => apply(fun, arg, e)
&#x200B;
```

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- `LetRec name value body` ⇓ v₂
```

---

.diff-add[
```scala
def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)                => Value.Num(value)
  case Bool(value)               => Value.Bool(value)
  case Add(lhs, rhs)             => add(lhs, rhs, e)
  case Gt(lhs, rhs)              => gt(lhs, rhs, e)
  case Cond(pred, onT, onF)      => cond(pred, onT, onF, e)
  case Let(name, value, body)    => let(name, value, body, e)
* `case LetRec(name, value, body) => letRec(name, value, body, e)`
  case Ref(name)                 => e.lookup(name)
  case Fun(param, body)          => Value.Fun(param, body, e)
  case Apply(fun, arg)           => apply(fun, arg, e)
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- `LetRec name value body` ⇓ v₂
```

---

```scala
def letRec(name: String, value: Expr, body: Expr, e: Env) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

.diff-add[
```scala
&#x200B;def letRec(name: String, value: Expr, body: Expr, e: Env) =
* `val eʹ = e.bind(name, null)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`eʹ = bind(e, name, ∅)`; eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

.diff-add[
```scala
&#x200B;def letRec(name: String, value: Expr, body: Expr, e: Env) =
  val eʹ = e.bind(name, null)
* `val v1 = interpret(value, eʹ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
eʹ = bind(e, name, ∅); `eʹ |- value ⇓ v₁`
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

.diff-add[
```scala
&#x200B;def letRec(name: String, value: Expr, body: Expr, e: Env) =
  val eʹ = e.bind(name, null)
  val v1 = interpret(value, eʹ)
*&#x200B;
* `eʹ.update(name, v1)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 `update(eʹ, name, v₁)`; eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

.diff-add[
```scala
&#x200B;def letRec(name: String, value: Expr, body: Expr, e: Env) =
  val eʹ = e.bind(name, null)
  val v1 = interpret(value, eʹ)
&#x200B;
  eʹ.update(name, v1)
* `val v2 = interpret(body, eʹ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); `eʹ |- body ⇓ v₂`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ v₂
```

---

.diff-add[
```scala
&#x200B;def letRec(name: String, value: Expr, body: Expr, e: Env) =
  val eʹ = e.bind(name, null)
  val v1 = interpret(value, eʹ)
&#x200B;
  eʹ.update(name, v1)
  val v2 = interpret(body, eʹ)
*&#x200B;
* `v2`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
eʹ = bind(e, name, ∅); eʹ |- value ⇓ v₁
 update(eʹ, name, v₁); eʹ |- body ⇓ v₂
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
   e |- LetRec name value body ⇓ `v₂`
```

---

```scala repl:invisible
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr, env: Env)

case class Env(env: List[Env.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
        .map(_.value)
        .getOrElse(sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(Env.Binding(name, value) :: env)

  def update(name: String, value: Value) =
    env.find(_.name == name)
       .foreach(_.value = value)

object Env:
  case class Binding(name: String, var value: Value)

  val empty = Env(List.empty)

enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
import Expr.*

def add(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(v1), Value.Num(v2)) => Value.Num(v1 + v2)
    case _                              => typeError("add")

def gt(lhs: Expr, rhs: Expr, e: Env) =
  (interpret(lhs, e), interpret(rhs, e)) match
    case (Value.Num(n), Value.Num(nʹ)) => Value.Bool(n > nʹ)
    case _                                => typeError("gt")

def cond(pred: Expr, onT: Expr, onF: Expr, e: Env) =
  interpret(pred, e) match
    case Value.Bool(true)  => interpret(onT, e)
    case Value.Bool(false) => interpret(onF, e)
    case _                 => typeError("cond")

def let(name: String, value: Expr, body: Expr, e: Env) =
  val v1 = interpret(value, e)
  val v2 = interpret(body, e.bind(name, v1))

  v2

def apply(fun: Expr, arg: Expr, e: Env) =
  interpret(fun, e) match
    case Value.Fun(param, body, closedEnv) =>
      val argValue  = interpret(arg, e)
      val functionEnv = closedEnv.bind(param, argValue)
      interpret(body, functionEnv)
    case other =>
      typeError("apply")

def letRec(name: String, value: Expr, body: Expr, e: Env) =
  val eʹ = e.bind(name, null)
  val v  = interpret(value, eʹ)

  eʹ.update(name, v)
  interpret(body, eʹ)

def interpret(expr: Expr, e: Env): Value = expr match
  case Num(value)                => Value.Num(value)
  case Bool(value)               => Value.Bool(value)
  case Add(lhs, rhs)             => add(lhs, rhs, e)
  case Gt(lhs, rhs)              => gt(lhs, rhs, e)
  case Cond(pred, onT, onF)      => cond(pred, onT, onF, e)
  case Let(name, value, body)    => let(name, value, body, e)
  case LetRec(name, value, body) => letRec(name, value, body, e)
  case Ref(name)                 => e.lookup(name)
  case Fun(param, body)          => Value.Fun(param, body, e)
  case Apply(fun, arg)           => apply(fun, arg, e)
```

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = Let(
  // ...
)
```

```scala
interpret(expr, Env.empty)
```

---

.diff-rm[
```ocaml
*&#x200B;`let` sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

.diff-rm[
```scala
*val expr = `Let`(
  // ...
)
```
]

```scala
interpret(expr, Env.empty)
```

---

.diff-add[
```ocaml
*&#x200B;`let rec` sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

.diff-add[
```scala
*val expr = `LetRec`(
  // ...
)
```
]

```scala
interpret(expr, Env.empty)
```

---


```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = LetRec(
  // ...
)
```

```scala repl:invisible
val expr = LetRec(
  name  = "sum",
  value = Fun(
    param = "lower",
    body  = Fun(
      param = "upper",
      body  = Cond(
        pred       = Gt(Ref("lower"), Ref("upper")),
        onT = Num(0),
        onF = Add(
          lhs = Ref("lower"),
          rhs = Apply(
            fun = Apply(Ref("sum"), Add(Ref("lower"), Num(1))),
            arg    = Ref("upper")))))),
  body = Apply(Apply(Ref("sum"), Num(1)), Num(10)))
```

```scala repl
interpret(expr, Env.empty)
```

---

## [Key takeaways](#conclusion)

--

* Loops are implemented as recursive functions

--

* Recursive functions need special syntax...

--

*  ... and a mutable environment

---

class: center, middle
name: typechecking

# Identifying invalid programs

---

```ocaml
1 + true
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
1 `+` true
```

```scala
val expr = `Add`(
  Num(1),
  Bool(true)
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
&#x200B;`1` + true
```

```scala
val expr = Add(
  `Num(1)`,
  Bool(true)
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
1 + `true`
```

```scala
val expr = Add(
  Num(1),
  `Bool(true)`
)
```

```scala
interpret(expr, Env.empty)
```

---

```ocaml
1 + true
```

```scala repl
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala
interpret(expr, Env.empty)
// ⛔ Type error in add
```

---

```scala
def typeCheck(expr: Expr): ??? =
```

---

```scala
def typeCheck(`expr: Expr`): ??? =
```

---

.diff-rm[
```scala
*def typeCheck(expr: Expr): `???` =
```
]

---

.diff-add[
```scala
*def typeCheck(expr: Expr): `Boolean` =
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
* `expr match`
*   `case Num(value)    => ???`
```
]

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
*   case Num(value)    => `???`
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
*   case Num(value)    => `true`
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
*   `case Bool(value)   => ???`
```
]

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
*   case Bool(value)   => `???`
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
*   case Bool(value)   => `true`
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
*   `case Add(lhs, rhs) => ???`
```
]

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
*   case Add(lhs, rhs) => `???`
```
]

---

.diff-add[
```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
*   case Add(lhs, rhs) => `typeCheck(lhs) && typeCheck(rhs)`
```
]

---

```ocaml
1 + true
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala
interpret(expr, Env.empty)
&#x200B;
```

---

```ocaml
1 + true
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

.diff-rm[
```scala
*&#x200B;`interpret(expr, Env.empty)`
&#x200B;
```
]

---

```ocaml
1 + true
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

.diff-add[
```scala
*&#x200B;`typeCheck(expr)`
&#x200B;
```
]

---

```ocaml
1 + true
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala repl:invisible
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```

```scala repl
typeCheck(expr)

```

---

```scala
def typeCheck(expr: Expr): Boolean =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
    case Add(lhs, rhs) => `typeCheck(lhs) && typeCheck(rhs)`
```

---

```scala
def typeCheck(expr: Expr): `Boolean` =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```

---

```scala
enum Type:
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
enum Type:
* `case Num`
&#x200B;
&#x200B;
&#x200B;
```
]


---

.diff-add[
```scala
enum Type:
  case Num
* `case Bool`
&#x200B;
&#x200B;
```
]



```scala repl:invisible
enum Type:
  case Num
  case Bool
```

---

.diff-rm[
```scala
*def typeCheck(expr: Expr): `Boolean` =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

---

.diff-add[
```scala
*def typeCheck(expr: Expr): `Either[String, Type]` =
  expr match
    case Num(value)    => true
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    `case Num(value)    => true`
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```

---

```scala
Num value : ???
```

```scala
1
```

---

```scala
&#x200B;`Num value` : ???
```

```scala
1
```

---

```scala
Num value `:` ???
```

```scala
1
```

---

.diff-rm[
```scala
*Num value : `???`
```
]

```scala
1
```

---

.diff-add[
```scala
*Num value : `Type.Num`
```
]

```scala
1
```

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
*   case Num(value)    => `true`
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

```scala
Num value : `Type.Num`
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => `Right(Type.Num)`
    case Bool(value)   => true
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

```scala
Num value : `Type.Num`
```

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    `case Bool(value)   => true`
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```

```scala
&#x200B;
```
---

```scala
Bool value : ???
```

```ocaml
true
```

---

.diff-rm[
```scala
*Bool value : `???`
```
]

```ocaml
true
```

---

.diff-add[
```scala
*Bool value : `Type.Bool`
```
]

```ocaml
true
```

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
*   case Bool(value)   => `true`
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

```scala
Bool value : `Type.Bool`
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
*   case Bool(value)   => `Right(Type.Bool)`
    case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)
```
]

```scala
Bool value : `Type.Bool`
```

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    `case Add(lhs, rhs) => typeCheck(lhs) && typeCheck(rhs)`
```

```scala
&#x200B;
```

---

```scala
      Add lhs rhs : ???
&#x200B;
&#x200B;
```

```ocaml
1 + 2
```

---

.diff-add[
```scala
*&#x200B;`lhs : Type.Num`
      Add lhs rhs : ???
&#x200B;
```
]

```ocaml
&#x200B;`1` + 2
```

---

.diff-add[
```scala
*lhs : Type.Num       `rhs : Type.Num`
      Add lhs rhs : ???
&#x200B;
```
]

```ocaml
1 + `2`
```

---

.diff-add[
```scala
lhs : Type.Num       rhs : Type.Num
*&#x200B;`⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯`
      Add lhs rhs : ???
```
]

```ocaml
1 + 2
```

---

.diff-rm[
```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Add lhs rhs : `???`
```
]

```ocaml
&#x200B;`1 + 2`
```

---

.diff-add[
```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Add lhs rhs : `Type.Num`
```
]

```ocaml
&#x200B;`1 + 2`
```

---

.diff-rm[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
*   case Add(lhs, rhs) => `typeCheck(lhs) && typeCheck(rhs)`
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
*   case Add(lhs, rhs) => `checkAdd(lhs, rhs)`
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

```scala
def checkAdd(lhs: Expr, rhs: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

```scala
def checkAdd(lhs: Expr, rhs: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`lhs : Type.Num`       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

```scala
def expect() =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`lhs : Type.Num`       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
*def expect(`expr: Expr`) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs` : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
*def expect(expr: Expr`, expected: Type`) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : `Type.Num`       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def expect(expr: Expr, expected: Type) =
* `typeCheck(expr).flatMap =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def expect(expr: Expr, expected: Type) =
* typeCheck(expr).flatMap`: observed` =>
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def expect(expr: Expr, expected: Type) =
  typeCheck(expr).flatMap: observed =>
*   `if observed == expected then`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def expect(expr: Expr, expected: Type) =
  typeCheck(expr).flatMap: observed =>
*   if observed == expected then `Right(())`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def expect(expr: Expr, expected: Type) =
  typeCheck(expr).flatMap: observed =>
    if observed == expected then Right(())
*   `else Left(s"Expected $expected, found $observed")`
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

```scala
def checkAdd(lhs: Expr, rhs: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def checkAdd(lhs: Expr, rhs: Expr) =
* `for _ <- expect(lhs, Type.Num)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs : Type.Num`       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def checkAdd(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
*     `_ <- expect(rhs, Type.Num)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       `rhs : Type.Num`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : Type.Num
```

---

.diff-add[
```scala
def checkAdd(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
      _ <- expect(rhs, Type.Num)
* `yield Type.Num`
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num       rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Add lhs rhs : `Type.Num`
```

```scala repl:invisible
def expect(expr: Expr, expected: Type) =
  typeCheck(expr).flatMap: observed =>
    if observed == expected then Right(())
    else Left(s"Expected $expected, found $observed")


def checkAdd(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
      _ <- expect(rhs, Type.Num)
  yield Type.Num

def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    case Add(lhs, rhs) => checkAdd(lhs, rhs)
```

---

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : ???
```
]

```ocaml
1 > 2
```

---

.diff-add[
```scala
*&#x200B;`lhs : Type.Num`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : ???
```
]

```ocaml
&#x200B;`1` > 2
```

---

.diff-add[
```scala
*lhs : Type.Num      `rhs : Type.Num`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : ???
```
]

```ocaml
1 > `2`
```

---

.diff-rm[
```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*    Gt lhs rhs : `???`
```
]

```ocaml
&#x200B;`1 > 2`
```

---

.diff-add[
```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*    Gt lhs rhs : `Type.Bool`
```
]

```ocaml
&#x200B;`1 > 2`
```

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    case Add(lhs, rhs) => checkAdd(lhs, rhs)
&#x200B;
```

```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : Type.Bool
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    case Add(lhs, rhs) => checkAdd(lhs, rhs)
*   `case Gt(lhs, rhs)  =>`
```
]

```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     `Gt lhs rhs` : Type.Bool
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    case Add(lhs, rhs) => checkAdd(lhs, rhs)
*   case Gt(lhs, rhs)  => `checkGt(lhs, rhs)`
```
]

```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : Type.Bool
```

---

```scala
def checkGt(lhs: Expr, rhs: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : Type.Bool
```

---

.diff-add[
```scala
*def checkGt(lhs: Expr, rhs: Expr) =
* `for _ <- expect(lhs, Type.Num)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs : Type.Num`      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : Type.Bool
```

---

.diff-add[
```scala
def checkGt(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
*     `_ <- expect(rhs, Type.Num)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num      `rhs : Type.Num`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : Type.Bool
```

---

.diff-add[
```scala
def checkGt(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
      _ <- expect(rhs, Type.Num)
* `yield Type.Bool`
&#x200B;
&#x200B;
```
]

```scala
lhs : Type.Num      rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Gt lhs rhs : `Type.Bool`
```

```scala repl:invisible
def checkGt(lhs: Expr, rhs: Expr) =
  for _ <- expect(lhs, Type.Num)
      _ <- expect(rhs, Type.Num)
  yield Type.Bool

def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)    => Right(Type.Num)
    case Bool(value)   => Right(Type.Bool)
    case Add(lhs, rhs) => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)  => checkGt(lhs, rhs)
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```


```ocaml
if true then 1
        else 2
```

---

.diff-add[
```scala
*&#x200B;`pred : Type.Bool`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```
]

```ocaml
if `true` then 1
        else 2
```

---

.diff-add[
```scala
*pred : Type.Bool      `onT : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```
]

```ocaml
if true then `1`
        else 2
```

---

.diff-add[
```scala
*pred : Type.Bool      onT : X      `onF : ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```
]

```ocaml
if true then 1
        else `2`
```

---

.diff-rm[
```scala
*pred : Type.Bool      onT : X      onF : `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```
]

```ocaml
if true then 1
        else `2`
```

---

.diff-add[
```scala
*pred : Type.Bool      onT : X       onF : `X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : ???
```
]

```ocaml
if true then 1
        else `2`
```

---

.diff-rm[
```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*        Cond pred onT onF : `???`
```
]

```ocaml
&#x200B;`if true then 1`
        `else 2`
```

---

.diff-add[
```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*        Cond pred onT onF : `X`
```
]

```ocaml
&#x200B;`if true then 1`
        `else 2`
```

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)           => Right(Type.Num)
    case Bool(value)          => Right(Type.Bool)
    case Add(lhs, rhs)        => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)         => checkGt(lhs, rhs)
&#x200B;
```

```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)           => Right(Type.Num)
    case Bool(value)          => Right(Type.Bool)
    case Add(lhs, rhs)        => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)         => checkGt(lhs, rhs)
*   `case Cond(pred, onT, onF) =>`
```
]

```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         `Cond pred onT onF` : X
```

---

.diff-add[
```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)           => Right(Type.Num)
    case Bool(value)          => Right(Type.Bool)
    case Add(lhs, rhs)        => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)         => checkGt(lhs, rhs)
*   case Cond(pred, onT, onF) => `checkCond(pred, onT, onF)`
```
]

```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

```scala
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

.diff-add[
```scala
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
* `for _ <- expect(pred, Type.Bool)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`pred : Type.Bool`      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

.diff-add[
```scala
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
  for _ <- expect(pred, Type.Bool)
*     `x <- typeCheck(onT)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred : Type.Bool      `onT : X`       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

.diff-add[
```scala
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
  for _ <- expect(pred, Type.Bool)
      x <- typeCheck(onT)
*     `_ <- expect(onF, x)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred : Type.Bool      onT : X       `onF : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : X
```

---

.diff-add[
```scala
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
  for _ <- expect(pred, Type.Bool)
      x <- typeCheck(onT)
      _ <- expect(onF, x)
* `yield x`
&#x200B;
&#x200B;
```
]

```scala
pred : Type.Bool      onT : X       onF : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
         Cond pred onT onF : `X`
```

```scala repl:invisible
def checkCond(pred: Expr, onT: Expr, onF: Expr) =
  for _ <- expect(pred, Type.Bool)
      x <- typeCheck(onT)
      _ <- expect(onF, x)
  yield x

def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)           => Right(Type.Num)
    case Bool(value)          => Right(Type.Bool)
    case Add(lhs, rhs)        => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)         => checkGt(lhs, rhs)
    case Cond(pred, onT, onF) => checkCond(pred, onT, onF)
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
           Let name value body : ???
```


```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
*&#x200B;`value : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
           Let name value body : ???
```
]

```ocaml
let x = `1` in
  x + 2
```

---

.diff-add[
```scala
*value : X                            `body : Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
           Let name value body : ???
```
]

```ocaml
let x = 1 in
  `x + 2`
```

---

.diff-add[
```scala
*&#x200B;`Γ |-` value : X                  `Γ |-` body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     `Γ |-` Let name value body : ???
```
]

```ocaml
let x = 1 in
  x + 2
```

---

```scala
&#x200B;`Γ |- value : X`                  Γ |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : ???
```

```ocaml
let x = 1 in
  x + 2
```

---

.diff-rm[
```scala
*Γ |- value : X                  `Γ` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : ???
```
]

```ocaml
let `x = 1` in
  x + 2
```

---

.diff-add[
```scala
*Γ |- value : X       `Γ[name <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : ???
```
]

```ocaml
let `x = 1` in
  x + 2
```

---

.diff-rm[
```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- Let name value body : `???`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- Let name value body : `Y`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

```scala
&#x200B;
&#x200B;
Γ |- Ref name : ???
```


```ocaml
let x = 1 in
  x + 2
```

---

.diff-rm[
```scala
&#x200B;
&#x200B;
*Γ |- Ref name : `???`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

.diff-add[
```scala
&#x200B;
&#x200B;
*Γ |- Ref name : `Γ(name)`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

```scala
&#x200B;
&#x200B;
&#x200B;`Γ` |- Ref name : Γ(name)
```

```ocaml
let x = 1 in
  x + 2
```

---

```scala
case class TypeEnv():
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
*case class TypeEnv(`env: List[TypeEnv.Binding]`):
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
*&#x200B;
*&#x200B;`object TypeEnv:`
* `case class Binding()`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
&#x200B;
object TypeEnv:
* case class Binding(`name: String`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
&#x200B;
object TypeEnv:
* case class Binding(name: String`, tpe: Type`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
* `def lookup(name: String) =`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
*   `env.find(_.name == name)`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
*      `.map(_.tpe)`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
*      `.toRight(s"Type binding $name not found")`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")
*&#x200B;
* `def bind(name: String, tpe: Type) =`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")
&#x200B;
  def bind(name: String, tpe: Type) =
*   `TypeEnv.Binding(name, tpe)`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")
&#x200B;
  def bind(name: String, tpe: Type) =
*   TypeEnv.Binding(name, tpe)` :: env`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")
&#x200B;
  def bind(name: String, tpe: Type) =
*   `TypeEnv(`TypeEnv.Binding(name, tpe) :: env`)`
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
&#x200B;
```
]

---

.diff-add[
```scala
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")
&#x200B;
  def bind(name: String, tpe: Type) =
    TypeEnv(TypeEnv.Binding(name, tpe) :: env)
&#x200B;
object TypeEnv:
  case class Binding(name: String, tpe: Type)
&#x200B;
* `val empty = TypeEnv(List.empty)`
```
]

```scala repl:invisible
case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")

  def bind(name: String, tpe: Type) =
    TypeEnv(TypeEnv.Binding(name, tpe) :: env)

object TypeEnv:
  case class Binding(name: String, tpe: Type)

  val empty = TypeEnv(List.empty)

def expect(expr: Expr, expected: Type, Γ: TypeEnv) =
  typeCheck(expr, Γ).flatMap: observed =>
    if observed == expected then Right(())
    else Left(s"Expected $expected, found $observed")

def checkAdd(lhs: Expr, rhs: Expr, Γ: TypeEnv) =
  for _ <- expect(lhs, Type.Num, Γ)
      _ <- expect(rhs, Type.Num, Γ)
  yield Type.Num

def checkGt(lhs: Expr, rhs: Expr, Γ: TypeEnv) = for
  _ <- expect(lhs, Type.Num, Γ)
  _ <- expect(rhs, Type.Num, Γ)
yield Type.Bool

def checkCond(pred: Expr, onT: Expr, onF: Expr, Γ: TypeEnv) =
  for _ <- expect(pred, Type.Bool, Γ)
      x <- typeCheck(onT, Γ)
      _ <- expect(onF, x, Γ)
  yield x

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)                => Right(Type.Num)
    case Bool(value)               => Right(Type.Bool)
    case Add(lhs, rhs)             => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)              => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)      => checkCond(pred, onT, onF, Γ)
```

---

```scala
def typeCheck(expr: Expr): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
*def typeCheck(expr: Expr`, Γ: TypeEnv`): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
*   case Add(lhs, rhs)          => checkAdd(lhs, rhs`, Γ`)
*   case Gt(lhs, rhs)           => checkGt(lhs, rhs`, Γ`)
*   case Cond(pred, onT, onF)   => checkCond(pred, onT, onF`, Γ`)
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
*   `case Let(name, value, body) =>`
&#x200B;
```
]

```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- `Let name value body` : Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
*   case Let(name, value, body) => `checkLet(name, value, body, Γ)`
&#x200B;
```
]

```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

.diff-add[
```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
* `for x <- typeCheck(value, Γ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Γ |- value : X`       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

.diff-add[
```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
*     `y <- typeCheck(body, ???)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- value : X       `Γ[name <- X] |- body : Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

.diff-rm[
```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
*     y <- typeCheck(body, `???`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- value : X       `Γ[name <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

.diff-add[
```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
*     y <- typeCheck(body, `Γ.bind(name, x)`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- value : X       `Γ[name <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : Y
```

---

.diff-add[
```scala
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
      y <- typeCheck(body, Γ.bind(name, x))
* `yield y`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- value : X       Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- Let name value body : `Y`
```

---

```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
&#x200B;
```

```scala
&#x200B;
&#x200B;
Γ |- `Ref name` : Γ(name)
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
*   `case Ref(name)              =>`
```
]

```scala
&#x200B;
&#x200B;
Γ |- `Ref name` : Γ(name)
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
*   case Ref(name)              => `Γ.lookup(name)`
```
]

```scala
&#x200B;
&#x200B;
Γ |- Ref name : `Γ(name)`
```

```scala repl:invisible
def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
      y <- typeCheck(body, Γ.bind(name, x))
  yield y

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
    case Ref(name)              => Γ.lookup(name)
```

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-add[
```scala
*    `Γ |- body : ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```
]

```ocaml
let f = x -> `x + 1` in
  f 2
```

---

```scala
     `Γ` |- body : ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-add[
```scala
*   `Γ[param <- X]` |- body : ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```
]

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-rm[
```scala
*   Γ[param <- X] |- body : `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```
]

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-add[
```scala
*   Γ[param <- X] |- body : `Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : ???
```
]

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-rm[
```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Γ |- Fun param body : `???`
```
]

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-add[
```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Γ |- Fun param body : `X -> Y`
```
]

```ocaml
let f = x -> x + 1 in
  f 2
```

---

```scala
    Γ[param <- `X`] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun param body : X -> Y
```

```ocaml
let f = x -> x + 1 in
  f 2
```

---

.diff-rm[
```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Γ |- Fun `param` body : X -> Y
```
]

.diff-rm[
```ocaml
*let f = `x` -> x + 1 in
  f 2
```
]

---

.diff-add[
```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Γ |- Fun `(param : X)` body : X -> Y
```
]

.diff-add[
```ocaml
*let f = `(x: Num)` -> x + 1 in
  f 2
```
]

---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Γ |- Apply fun arg : ???
```


```ocaml
let f = (x: Num) -> x + 1 in
  f 2
```

---

.diff-add[
```scala
*&#x200B;`Γ |- fun : ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Γ |- Apply fun arg : ???
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  `f` 2
```

---

.diff-rm[
```scala
*&#x200B;Γ |- fun : `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Γ |- Apply fun arg : ???
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  `f` 2
```

---

.diff-add[
```scala
*&#x200B;Γ |- fun : `X -> Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Γ |- Apply fun arg : ???
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  `f` 2
```

---

.diff-add[
```scala
*Γ |- fun : X -> Y     `Γ |- arg : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
     Γ |- Apply fun arg : ???
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  f `2`
```

---

.diff-rm[
```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*    Γ |- Apply fun arg : `???`
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  `f 2`
```

---

.diff-add[
```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*    Γ |- Apply fun arg : `Y`
```
]

```ocaml
let f = (x: Num) -> x + 1 in
  `f 2`
```

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String )
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : `X`) body : X -> Y
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String )
* case Fun(param: String`, pType: Type`, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : `X`) body : X -> Y
```

---

```scala
enum Type:
  case Num
  case Bool
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : `X -> Y`
```

---

.diff-add[
```scala
enum Type:
  case Num
  case Bool
* `case Fun()`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : `X -> Y`
```


---

.diff-add[
```scala
enum Type:
  case Num
  case Bool
* case Fun(`from: Type`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : `X` -> Y
```

---

.diff-add[
```scala
enum Type:
  case Num
  case Bool
* case Fun(from: Type`, to: Type`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> `Y`
```



```scala repl:invisible
enum Type:
  case Num
  case Bool
  case Fun(from: Type, to: Type)

object `->`:
  def unapply(tpe: Type): Option[(Type, Type)] = tpe match
    case Type.Fun(from, to) => Some((from, to))
    case other              => None

extension (from: Type) def ->(to: Type) = Type.Fun(from, to)

Type.Num -> Type.Bool match
  case from -> to => s"Function: $from -> $to"
  case _          => "Not a function!"
```


```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String )
  case Fun(param: String, pType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)
import Expr.*

case class TypeEnv(env: List[TypeEnv.Binding]):
  def lookup(name: String) =
    env.find(_.name == name)
       .map(_.tpe)
       .toRight(s"Type binding $name not found")

  def bind(name: String, tpe: Type) =
    TypeEnv(TypeEnv.Binding(name, tpe) :: env)

object TypeEnv:
  case class Binding(name: String, tpe: Type)

  val empty = TypeEnv(List.empty)

def expect(expr: Expr, expected: Type, Γ: TypeEnv) =
  typeCheck(expr, Γ).flatMap: observed =>
    if observed == expected then Right(())
    else Left(s"Expected $expected, found $observed")

def checkAdd(lhs: Expr, rhs: Expr, Γ: TypeEnv) =
  for _ <- expect(lhs, Type.Num, Γ)
      _ <- expect(rhs, Type.Num, Γ)
  yield Type.Num

def checkGt(lhs: Expr, rhs: Expr, Γ: TypeEnv) = for
  _ <- expect(lhs, Type.Num, Γ)
  _ <- expect(rhs, Type.Num, Γ)
yield Type.Bool

def checkCond(pred: Expr, onT: Expr, onF: Expr, Γ: TypeEnv) =
  for _ <- expect(pred, Type.Bool, Γ)
      x <- typeCheck(onT, Γ)
      _ <- expect(onF, x, Γ)
  yield x

def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
      y <- typeCheck(body, Γ.bind(name, x))
  yield y

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)               => Right(Type.Num)
    case Bool(value)              => Right(Type.Bool)
    case Add(lhs, rhs)            => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)             => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)     => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)   => checkLet(name, value, body, Γ)
    case Ref(name)                => Γ.lookup(name)
```

---

```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
    case Ref(name)              => Γ.lookup(name)
&#x200B;
&#x200B;
```

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- `Fun (param : X) body` : X -> Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
    case Ref(name)              => Γ.lookup(name)
*   `case Fun(param, x, body)    =>`
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- `Fun (param : X) body` : X -> Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)             => Right(Type.Num)
    case Bool(value)            => Right(Type.Bool)
    case Add(lhs, rhs)          => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)           => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)   => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body) => checkLet(name, value, body, Γ)
    case Ref(name)              => Γ.lookup(name)
*   case Fun(param, x, body)    => `checkFun(param, x, body Γ)`
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> Y
```

---

```scala
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> Y
```

---

.diff-add[
```scala
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
* `for y <- typeCheck(body, ???)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    Γ[param <- X] |- `body : Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> Y
```

---

.diff-rm[
```scala
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
* for y <- typeCheck(body, `???`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    `Γ[param <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> Y
```

---

.diff-add[
```scala
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
* for y <- typeCheck(body, `Γ.bind(param, x)`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    `Γ[param <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : X -> Y
```

---

.diff-add[
```scala
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
  for y <- typeCheck(body, Γ.bind(param, x))
* `yield x -> y`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
    Γ[param <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun (param : X) body : `X -> Y`
```

---

```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
&#x200B;
```

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- `Apply fun arg` : Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
*   `case Apply(fun, arg)         =>`
```
]

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- `Apply fun arg` : Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
*   case Apply(fun, arg)         => `checkApply(fun, arg, Γ)`
```
]

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
* `typeCheck(fun, Γ).flatMap:`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Γ |- fun` : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
*   `case x -> y =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- fun : `X -> Y`     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
*   case x -> y => `expect(arg, x, Γ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- fun : X -> Y     `Γ |- arg : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
    case x -> y => expect(arg, x, Γ)
*                    `.map(_ => y)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : `Y`
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
    case x -> y => expect(arg, x, Γ)
                     .map(_ => y)
*   `case other  =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

---

.diff-add[
```scala
def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
    case x -> y => expect(arg, x, Γ)
                     .map(_ => y)
*   case other  => `Left(s"Expected function, found $other")`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ |- fun : X -> Y     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
    Γ |- Apply fun arg : Y
```

```scala repl:invisible
def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
  for y <- typeCheck(body, Γ.bind(param, x))
  yield x -> y

def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
    case x -> y => expect(arg, x, Γ)
                     .map(_ => y)
    case other  => Left(s"Expected function, found $other")

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Apply(fun, arg)         => checkApply(fun, arg, Γ)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
```


---

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-add[
```scala
*&#x200B;`??? |- value : X`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = `(lower: Num) -> (upper: Num) ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-rm[
```scala
*&#x200B;`???` |- value : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = `(lower: Num) -> (upper: Num) ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
*&#x200B;`Γ[name <- X]` |- value : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = `(lower: Num) -> (upper: Num) ->`
    `if lower > upper then 0`
    `else lower + (sum (lower + 1) upper)`
  in sum 1 10
```

---

.diff-add[
```scala
*Γ[name <- X] |- value : X               `??? |- body : Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-rm[
```scala
*Γ[name <- X] |- value : X               `???` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-add[
```scala
*Γ[name <- X] |- value : X      `Γ[name <- X]` |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : ???
```
]

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in `sum 1 10`
```

---

.diff-rm[
```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- LetRec name value body : `???`
```
]

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-add[
```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- LetRec name value body : `Y`
```
]

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

```scala
Γ[name <- `X`] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name value body : Y
```

```scala
let rec sum = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

.diff-rm[
```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- LetRec name `value` body : Y
```
]

.diff-rm[
```scala
*let rec `sum` = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

---

.diff-add[
```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*     Γ |- LetRec name `(value : X)` body : Y
```
]

.diff-add[
```scala
*let rec `(sum: Num -> Num -> Num)` = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```
]

---

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Ref(name: String)
  case Fun(param: String, paramType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
&#x200B;
```

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : `X`) body : Y
```

---

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case LetRec(name: String, value: Expr`, vType: Type`, body: Expr)
  case Ref(name: String)
  case Fun(param: String, paramType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
&#x200B;
```
]

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : `X`) body : Y
```

```scala repl:invisible
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, onT: Expr, onF: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, vType: Type, body: Expr)
  case Ref(name: String)
  case Fun(param: String, paramType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)

import Expr.*

def expect(expr: Expr, expected: Type, Γ: TypeEnv) =
  typeCheck(expr, Γ).flatMap: observed =>
    if observed == expected then Right(())
    else Left(s"Expected $expected, found $observed")

def checkAdd(lhs: Expr, rhs: Expr, Γ: TypeEnv) =
  for _ <- expect(lhs, Type.Num, Γ)
      _ <- expect(rhs, Type.Num, Γ)
  yield Type.Num

def checkGt(lhs: Expr, rhs: Expr, Γ: TypeEnv) = for
  _ <- expect(lhs, Type.Num, Γ)
  _ <- expect(rhs, Type.Num, Γ)
yield Type.Bool

def checkCond(pred: Expr, onT: Expr, onF: Expr, Γ: TypeEnv) =
  for _ <- expect(pred, Type.Bool, Γ)
      x <- typeCheck(onT, Γ)
      _ <- expect(onF, x, Γ)
  yield x

def checkLet(name: String, value: Expr, body: Expr, Γ: TypeEnv) =
  for x <- typeCheck(value, Γ)
      y <- typeCheck(body, Γ.bind(name, x))
  yield y

def checkFun(param: String, x: Type, body: Expr, Γ: TypeEnv) =
  typeCheck(body, Γ.bind(param, x)).map: y =>
    Type.Fun(x, y)

def checkApply(fun: Expr, arg: Expr, Γ: TypeEnv) =
  typeCheck(fun, Γ).flatMap:
    case x -> y => expect(arg, x, Γ).map(_ => y)
    case other  => Left(s"Expected function, found $other")

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)                => Right(Type.Num)
    case Bool(value)               => Right(Type.Bool)
    case Add(lhs, rhs)             => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)              => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)      => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)    => checkLet(name, value, body, Γ)
    case LetRec(name, value, valueType, body) => ???
    case Ref(name)                 => Γ.lookup(name)
    case Fun(param, paramType, body) => checkFun(param, paramType, body, Γ)
    case Apply(fun, arg)      => checkApply(fun, arg, Γ)
```

---

```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Apply(fun, arg)         => checkApply(fun, arg, Γ)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
&#x200B;
&#x200B;
```

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Apply(fun, arg)         => checkApply(fun, arg, Γ)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
*   `case LetRec(name, value, x, body) =>`
&#x200B;
```
]

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- `LetRec name (value : X) body` : Y
```

---

.diff-add[
```scala
def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Apply(fun, arg)         => checkApply(fun, arg, Γ)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
    case LetRec(name, value, x, body) =>
*     `checkLetRec(name, value, x, body, Γ)`
```
]

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

```scala
def checkLetRec(name: String, value: Expr, x: Type,
                body: Expr, Γ: TypeEnv) =
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

.diff-add[
```scala
def checkLetRec(name: String, value: Expr, x: Type,
                body: Expr, Γ: TypeEnv) =
* `val eʹ = Γ.bind(name, x)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Γ[name <- X]` |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

.diff-add[
```scala
def checkLetRec(name: String, value: Expr, x: Type,
                body: Expr, Γ: TypeEnv) =
  val eʹ = Γ.bind(name, x)
&#x200B;
* `for _ <- expect(value, x, eʹ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ[name <- X] |- `value : X`      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

.diff-add[
```scala
def checkLetRec(name: String, value: Expr, x: Type,
                body: Expr, Γ: TypeEnv) =
  val eʹ = Γ.bind(name, x)
&#x200B;
  for _ <- expect(value, x, eʹ)
*     `y <- typeCheck(body, eʹ)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ[name <- X] |- value : X      `Γ[name <- X] |- body : Y`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : Y
```

---

.diff-add[
```scala
def checkLetRec(name: String, value: Expr, x: Type,
                body: Expr, Γ: TypeEnv) =
  val eʹ = Γ.bind(name, x)
&#x200B;
  for _ <- expect(value, x, eʹ)
      y <- typeCheck(body, eʹ)
* `yield y`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Γ[name <- X] |- value : X      Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
      Γ |- LetRec name (value : X) body : `Y`
```

---

```scala repl:invisible
def checkLetRec(name: String, value: Expr, x: Type, body: Expr, Γ: TypeEnv) =
  val eʹ = Γ.bind(name, x)

  for
    _ <- expect(value, x, eʹ)
    y <- typeCheck(body, eʹ)
  yield y

def typeCheck(expr: Expr, Γ: TypeEnv): Either[String, Type] =
  expr match
    case Num(value)              => Right(Type.Num)
    case Bool(value)             => Right(Type.Bool)
    case Add(lhs, rhs)           => checkAdd(lhs, rhs, Γ)
    case Gt(lhs, rhs)            => checkGt(lhs, rhs, Γ)
    case Cond(pred, onT, onF)    => checkCond(pred, onT, onF, Γ)
    case Let(name, value, body)  => checkLet(name, value, body, Γ)
    case Ref(name)               => Γ.lookup(name)
    case Apply(fun, arg)         => checkApply(fun, arg, Γ)
    case Fun(param, pType, body) => checkFun(param, pType, body, Γ)
    case LetRec(name, value, x, body) => checkLetRec(name, value, x, body, Γ)
```

```ocaml
1 + true
&#x200B;
&#x200B;
&#x200B;
```

```scala
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala
typeCheck(expr, TypeEnv.empty)
&#x200B;
```

---

```ocaml
1 + true
&#x200B;
&#x200B;
&#x200B;
```

```scala repl:silent
val expr = Add(
  Num(1),
  Bool(true)
)
```

```scala repl
typeCheck(expr, TypeEnv.empty)
```

---


```ocaml
let rec (sum: Num -> Num -> Num) = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = LetRec(
  // ...
)
&#x200B;
```

```scala
typeCheck(expr, TypeEnv.empty)
&#x200B;
```

---

```ocaml
let rec (sum: Num -> Num -> Num) = (lower: Num) -> (upper: Num) ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

```scala
val expr = LetRec(
  // ...
)
&#x200B;
```

```scala repl:invisible
val expr = LetRec(
  name  = "sum",
  vType = Type.Fun(Type.Num, Type.Fun(Type.Num, Type.Num)),
  value = Fun(
    param     = "lower",
    paramType = Type.Num,
    body      = Fun(
      param     = "upper",
      paramType = Type.Num,
      body      = Cond(
        pred       = Gt(Ref("lower"), Ref("upper")),
        onT = Num(0),
        onF = Add(
          lhs = Ref("lower"),
          rhs = Apply(
            fun = Apply(Ref("sum"), Add(Ref("lower"), Num(1))),
            arg      = Ref("upper"))
        )
      )
    )
  ),
  body = Apply(Apply(Ref("sum"), Num(1)), Num(10))
)
```

```scala repl
typeCheck(expr, TypeEnv.empty)
```

---

## [Key takeaways](#conclusion)

--

* Type checking is very similar to interpretation

--

* It follows the same "formalise / implement" logic

--

* We're still allowing illegal programs though...


---
class: center, middle
name: conclusion

# In closing

---

## If you only remember 1 slide...

--

* Programs are represented as ASTs

--

* We use formal semantics to reason about them

--

* Implementation is then relatively straightforward

---

class: center, middle
name: questions

[<img src="img/qr-code.svg" width="50%" height="50%"/>][Slides]

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]

---

class: center, middle

# Typed Expression

---

```scala repl
enum TypedExpr[A]:
  case Num(value: Int) extends TypedExpr[Type.Num.type]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool.type]
  case Add(lhs: TypedExpr[Type.Num.type], rhs: TypedExpr[Type.Num.type]) extends TypedExpr[Type.Num.type]
  case Gt(lhs: TypedExpr[Type.Num.type], rhs: TypedExpr[Type.Num.type]) extends TypedExpr[Type.Bool.type]
  case Cond[A](pred: TypedExpr[Type.Bool.type], onT: TypedExpr[A], onF: TypedExpr[A]) extends TypedExpr[A]
  case Let[A, B](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A](name: String, value: TypedExpr[Type.Fun], body: TypedExpr[A]) extends TypedExpr[A]
  case Ref[A](name: String) extends TypedExpr[A]
  case Fun[A](param: String, body: TypedExpr[A]) extends TypedExpr[Type.Fun]
  case Apply[A, B](fun: TypedExpr[Type.Fun], arg: TypedExpr[A]) extends TypedExpr[B]
```

---

```scala repl
enum Type:
  case Num
  case Bool
  case Fun(from: Type, to: Type)

object Type:
  type Num = Type.Num.type
  type Bool = Type.Bool.type
```

---

```scala repl
enum TypedExpr[A]:
  case Num(value: Int) extends TypedExpr[Type.Num]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool]
  case Add(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Num]
  case Gt(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Bool]
  case Cond[A](pred: TypedExpr[Type.Bool], onT: TypedExpr[A], onF: TypedExpr[A]) extends TypedExpr[A]
  case Let[A, B](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A](name: String, value: TypedExpr[Type.Fun], body: TypedExpr[A]) extends TypedExpr[A]
  case Fun[A](param: String, body: TypedExpr[A]) extends TypedExpr[Type.Fun]
  case Ref[A](name: String) extends TypedExpr[A]
  case Apply[A, B](fun: TypedExpr[Type.Fun], arg: TypedExpr[A]) extends TypedExpr[B]
```

---

```scala repl
enum Type:
  case Num
  case Bool
  case Fun[From <: Type, To <: Type](from: From, to: To)

object Type:
  type Num = Type.Num.type
  type Bool = Type.Bool.type

type ->[A <: Type, B <: Type] = Type.Fun[A, B]
```

---

```scala repl
enum TypedExpr[A <: Type]:
  case Num(value: Int) extends TypedExpr[Type.Num]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool]
  case Add(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Num]
  case Gt(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Bool]
  case Cond[A <: Type](pred: TypedExpr[Type.Bool], onT: TypedExpr[A], onF: TypedExpr[A]) extends TypedExpr[A]
  case Let[A <: Type, B <: Type](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A <: Type, B <: Type, C <: Type](name: String, value: TypedExpr[A -> B], body: TypedExpr[C]) extends TypedExpr[C]
  case Ref[A <: Type](name: String) extends TypedExpr[A]
  case Fun[A <: Type, B <: Type](param: String, body: TypedExpr[B]) extends TypedExpr[A -> B]
  case Apply[A <: Type, B <: Type](fun: TypedExpr[A -> B], arg: TypedExpr[A]) extends TypedExpr[B]
```

---

```scala repl
import TypedExpr.*
Let(
  name  = "x",
  value = Bool(true),
  body  = Add(Ref("x"), Num(1))
)
```

---

```scala repl
val expr: TypedExpr[Type.Bool -> Type.Num] = Fun(
  param = "x",
  body  = Add(Ref("x"), Num(1))
)
```

---

## TOC

* [Representing code](#ast)
* [Taking decisions](#conditionals)
* [Naming things](#bindings)
* [Reusing Code](#functions)
* [Repeating actions](#recursion)
* [Identifying invalid programs](#typechecking)

[@NicolasRinaudo@functional.cafe]:https://functional.cafe/@NicolasRinaudo
[Nicolas Rinaudo]:https://nrinaudo.com/
[Slides]:https://nrinaudo.com/writing-pl/
    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
