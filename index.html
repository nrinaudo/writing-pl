<!Doctype html>
<html>
    <head>
        <title>Programming a language</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# Programming a language

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]

---

class: center, middle

# The substitution model

---

## Interpreting code

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f x = x + 1
&#x200B;
f 2
&#x200B;
```

---

## Interpreting code

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`let f x = x + 1`
&#x200B;
f 2
&#x200B;
```

---

## Interpreting code

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let f x = x + 1`
*&#x200B;
f 2
&#x200B;
```
]

---

## Interpreting code

.diff-add[
```ocaml
*&#x200B;`f x = x + 1`
&#x200B;
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
f 2
&#x200B;
&#x200B;
&#x200B;
```

---

## Interpreting code

```ocaml
f x = x + 1
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f 2`
&#x200B;
&#x200B;
&#x200B;
```


---

## Interpreting code

```ocaml
&#x200B;`f x` = x + 1
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f 2`
&#x200B;
&#x200B;
&#x200B;
```

---

## Interpreting code


```ocaml
f x = x + 1
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`f 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Interpreting code


.diff-add[
```ocaml
f x = x + 1
*&#x200B;`x   = 2`
&#x200B;
&#x200B;
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Interpreting code


```ocaml
f x = x + 1
&#x200B;`x`   = 2
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`x` + 1
&#x200B;
&#x200B;
&#x200B;
```

---

## Interpreting code


```ocaml
f x = x + 1
x   = 2
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + 1
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Interpreting code

```ocaml
f x = x + 1
x   = 2
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`2` + 1
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Interpreting code

```ocaml
f x = x + 1
x   = 2
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`2 + 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Interpreting code

```ocaml
f x = x + 1
x   = 2
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Dealing with ambiguities

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f x = x + x
let g y = f (y + 3)
&#x200B;
g 2
```

---

## Dealing with ambiguities

```ocaml
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
&#x200B;`let f x = x + x`
let g y = f (y + 3)
&#x200B;
g 2
```
]

---

## Dealing with ambiguities

.diff-add[
```ocaml
*&#x200B;`f x = x + x`
&#x200B;
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
let g y = f (y + 3)
&#x200B;
g 2
&#x200B;
```

---

## Dealing with ambiguities

```ocaml
f x = x + x
&#x200B;
&#x200B;
&#x200B;
```


<hr/>

.diff-rm[
```ocaml
*&#x200B;`let g y = f (y + 3)`
*&#x200B;
g 2
&#x200B;
```
]

---

## Dealing with ambiguities

.diff-add[
```ocaml
f x = x + x
*&#x200B;`g y = f (y + 3)`
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
g 2
&#x200B;
&#x200B;
&#x200B;
```

---

## Dealing with ambiguities

```ocaml
f x = x + x
&#x200B;`g y` = f (y + 3)
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`g 2`
&#x200B;
&#x200B;
&#x200B;
```

---

## Dealing with ambiguities

```ocaml
f x = x + x
g y = f (y + 3)
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`g 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Dealing with ambiguities

.diff-add[
```ocaml
f x = x + x
g y = f (y + 3)
*&#x200B;`y   = 2`
&#x200B;
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`f (y + 3)`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Dealing with ambiguities

```ocaml
&#x200B;`f x` = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f (y + 3)`
&#x200B;
&#x200B;
&#x200B;
```

---

## Dealing with ambiguities

```ocaml
f x = x + x
g y = f (y + 3)
&#x200B;`y`   = 2
&#x200B;
```

<hr/>

```ocaml
f (`y` + 3)
&#x200B;
&#x200B;
&#x200B;
```

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*f (`y` + 3)
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 1

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*f (`2` + 3)
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 2

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*f `(2 + 3)`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 2

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*f `5`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 3

---

## Innermost first

```ocaml
&#x200B;`f x` = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f 5`
&#x200B;
&#x200B;
&#x200B;
```


Count = 3

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`f 5`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 3

---

## Innermost first

.diff-add[
```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
*&#x200B;`x   = 5`
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + x`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 4

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;`x`   = 5
```

<hr/>

```ocaml
&#x200B;`x` + `x`
&#x200B;
&#x200B;
&#x200B;
```

Count = 4

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = 5
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + `x`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 4


---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = 5
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`5` + `5`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 5

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = 5
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`5 + 5`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 5

---

## Innermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = 5
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`10`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 6

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

```ocaml
f (y + 3)
&#x200B;
&#x200B;
&#x200B;
```

Count = 1

---

## Outermost first

```ocaml
&#x200B;`f x` = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f (y + 3)`
&#x200B;
&#x200B;
&#x200B;
```

Count = 1

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`f (y + 3)`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 1

---

## Outermost first

.diff-add[
```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
*&#x200B;`x   = y + 3`
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + x`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 2

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
&#x200B;`x`   = y + 3
```

<hr/>

```ocaml
&#x200B;`x` + `x`
&#x200B;
&#x200B;
&#x200B;
```

Count = 2

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + `x`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 2


---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`y + 3` + `y + 3`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 3

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
&#x200B;`y`   = 2
x   = y + 3
```

<hr/>

```ocaml
&#x200B;`y` + 3 + `y` + 3
&#x200B;
&#x200B;
&#x200B;
```

Count = 3

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`y` + 3 + `y` + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 3

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`2` + 3 + `2` + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 4

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`2 + 3` + 2 + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 4


---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`5` + 2 + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 5

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`5 + 2` + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 5

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`7` + 3
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 6

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`7 + 3`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 6

---

## Outermost first

```ocaml
f x = x + x
g y = f (y + 3)
y   = 2
x   = y + 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`10`
&#x200B;
&#x200B;
&#x200B;
```
]

Count = 7

---

## [Key takeaways](#conclusion)

* Interpretation is done by substitution

--

* We'll be doing eager evaluation

---

class: center, middle

# Representing source code

---

## Number literals

```scala
1
```


---

## Addition


.diff-add[
```scala
*1 `+ 2`
```
]

---

## Modelisation

```scala
enum Expr:
&#x200B;
&#x200B;
```

```scala
1 + 2
```

---

## Modelisation

.diff-add[
```scala
enum Expr:
* `case Num(value: Int)`
&#x200B;
```
]

```scala
&#x200B;`1` + `2`
```

---

## Modelisation

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* `case Add()`
```
]

```scala
1 `+` 2
```

---

## Modelisation

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(`lhs: Num`)
```
]

```scala
&#x200B;`1` + 2
```

---

## Modelisation

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: Num`, rhs: Num`)
```
]

```scala
1 + `2`
```

---

## Formal semantics: number literals

```scala
&#x200B;
&#x200B;
&#x200B;
```

```scala
1 + 2
```

---

## Formal semantics: number literals

```scala
&#x200B;`Num value` ⇓ ???
&#x200B;
&#x200B;
```

```scala
1 + `2`
```

---

## Formal semantics: number literals

```scala
Num value `⇓` ???
&#x200B;
&#x200B;
```

```scala
1 + `2`
```

---

## Formal semantics: number literals

.diff-rm[
```scala
*Num value ⇓ `???`
&#x200B;
&#x200B;
```
]

```scala
1 + `2`
```

---

## Formal semantics: number literals

.diff-add[
```scala
*Num value ⇓ `value`
&#x200B;
&#x200B;
```
]

```scala
1 + `2`
```

---

## Formal semantics: addition

```scala
Add ⇓ ???
&#x200B;
&#x200B;
```

```scala
1 `+` 2
```

---

## Formal semantics: addition

.diff-add[
```scala
*Add `lhs` ⇓ ???
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`1` + 2
```

---

## Formal semantics: addition

.diff-add[
```scala
*Add lhs `rhs` ⇓ ???
&#x200B;
&#x200B;
```
]

```scala
1 + `2`
```

---

## Formal semantics: addition

.diff-rm[
```scala
*Add lhs rhs ⇓ `???`
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`1 + 2`
```

---

## Formal semantics: addition

.diff-add[
```scala
*Add lhs rhs ⇓ `lhs + rhs`
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`1 + 2`
```

---

## Formal semantics: addition

```scala
Add `lhs` `rhs` ⇓ lhs + rhs
&#x200B;
&#x200B;
```


```scala
1 + 2
```

---

## Formal semantics: addition

.diff-add[
```scala
*&#x200B;`lhs ⇓ n1`
Add lhs rhs ⇓ lhs + rhs
&#x200B;
```
]


```scala
&#x200B;`1` + 2
```

---

## Formal semantics: addition

.diff-add[
```scala
*lhs ⇓ n1                                                  `rhs ⇓ n2`
Add lhs rhs ⇓ lhs + rhs
&#x200B;
```
]


```scala
1 + `2`
```

---

## Formal semantics: addition

.diff-add[
```scala
lhs ⇓ n1                                                  rhs ⇓ n2
*&#x200B;`⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯`
Add lhs rhs ⇓ lhs + rhs
```
]


```scala
1 + 2
```

---

## Formal semantics: addition

.diff-rm[
```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Add lhs rhs ⇓ `lhs + rhs`
```
]


```scala
&#x200B;`1 + 2`
```

---

## Formal semantics: addition

.diff-add[
```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Add lhs rhs ⇓ `n1 + n2`
```
]


```scala
&#x200B;`1 + 2`
```

---

## Interpretation

```scala
def interpret(expr: Expr): Int = ???
&#x200B;
&#x200B;
```

---

## Interpretation

.diff-rm[
```scala
*def interpret(expr: Expr): Int = `???`
&#x200B;
&#x200B;
```
]

---

## Interpretation

.diff-add[
```scala
*def interpret(expr: Expr): Int = `expr match`
&#x200B;
&#x200B;
```
]

---

## Interpretation: number literals

```scala
def interpret(expr: Expr): Int = expr match
&#x200B;
&#x200B;
```

```scala
Num value ⇓ value
&#x200B;
&#x200B;
```

---

## Interpretation: number literals

```scala
def interpret(expr: Expr): Int = expr match
&#x200B;
&#x200B;
```

.diff-add[
```scala
*&#x200B;
*&#x200B;`⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯`
Num value ⇓ value
```
]


---

## Interpretation: number literals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
* `case Num(value)    =>`
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Num value` ⇓ value
```

---

## Interpretation: number literals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
* case Num(value)    => `value`
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Num value ⇓ `value`
```

---

## Interpretation: addition

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
&#x200B;
```

```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 + n2
```

---

## Interpretation: addition

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* `case Add(lhs, rhs) =>`
```
]

```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Add lhs rhs` ⇓ n1 + n2
```

---

## Interpretation: addition

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* case Add(lhs, rhs) => `interpret(lhs)`
```
]

```scala
&#x200B;`lhs ⇓ n1`                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ `n1` + n2
```

---

## Interpretation: addition

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* case Add(lhs, rhs) => interpret(lhs) `+`
```
]

```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 `+` n2
```

---

## Interpretation: addition

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
* case Add(lhs, rhs) => interpret(lhs) + `interpret(rhs)`
```
]

```scala
lhs ⇓ n1                                                  `rhs ⇓ n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 + `n2`
```

---

## Checking our work

```ocaml
1 + 2
&#x200B;
&#x200B;
```

--

```scala
val expr = Add(Num(1), Num(2))
```

---

## Checking our work

```ocaml
1 `+` 2
&#x200B;
&#x200B;
```

```scala
val expr = `Add`(Num(1), Num(2))
```

---

## Checking our work

```ocaml
&#x200B;`1` + 2
&#x200B;
&#x200B;
```

```scala
val expr = Add(`Num(1)`, Num(2))
```

---

## Checking our work

```ocaml
&#x200B;1 + `2`
&#x200B;
&#x200B;
```

```scala
val expr = Add(Num(1), `Num(2)`)
```

---

## Checking our work

```ocaml
1 + 2
&#x200B;
&#x200B;
```

```scala
val expr = Add(Num(1), Num(2))

```

```scala
interpret(expr)
// val res0: Int = 3
```

---

## Abstract Syntax (Tree)

```ocaml
1 + 2
(1 + 2)
&#x200B;
```

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
// val res0: Int = 3
```


---

## Abstract Syntax (Tree)

```ocaml
1 + 2
(1 + 2)
((1)    +   ((2)))
```

```scala
val expr = Add(Num(1), Num(2))
```

```scala
interpret(expr)
// val res0: Int = 3
```

---

## (Abstract) Syntax Tree

.center[![](img/ast.svg)]

```ocaml
1 + 2
```

---

## (Abstract) Syntax Tree

.center[![](img/ast-root.svg)]

```ocaml
1 `+` 2
```

---

## (Abstract) Syntax Tree

.center[![](img/ast-leaves.svg)]

```ocaml
&#x200B;`1` + `2`
```

---

## Nested expressions

.center[![](img/ast-rhs-2-remove.svg)]

.diff-rm[
```ocaml
*1 + `2`
```
]

---

## Nested expressions

.center[![](img/ast-rhs-add-what.svg)]

.diff-add[
```ocaml
*1 + `(2 + 3)`
```
]

---

## Nested expressions

.diff-rm[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: `Num`, rhs: `Num`)
```
]

---

## Nested expressions


.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Add(lhs: `Expr`, rhs: `Expr`)
```
]

---

## Nested expressions

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
  case Add(lhs, rhs) => interpret(lhs) + interpret(rhs)
```

```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 + n2
```

---

## Nested expressions

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)    => value
  case Add(lhs, rhs) => `interpret(lhs)` + interpret(rhs)
```

```scala
&#x200B;`lhs ⇓ n1`                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 + n2
```

---

## Nested expressions

```ocaml
1 + (2 + 3)
```

--

```scala
val expr = Add(Num(1), Add(Num(2), Num(3)))

```

--

```scala
interpret(expr)
// val res1: Int = 6
```

---

## [Key takeaways](#conclusion)

* Source code is represented as an AST

--

* An AST is a recursive data type

--

* Interpretation is a simple recursive pattern match


---

class: center, middle

# Taking decisions

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*if true then `1 + 2`
        else 3 + 4
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*if true then `3`
        else 3 + 4
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
if true then 3
*       else `3 + 4`
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-add[
```ocaml
if true then 3
*       else `7`
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
if `true` then 3
        else 7
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`if true then `3
*&#x200B;`        else 7`
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3`
&#x200B;
```
]

---

## Substitution


```ocaml
&#x200B;
```

<hr/>


```ocaml
if `true` then 1 + 2
        else 3 + 4
```

---

## Substitution


```ocaml
&#x200B;
```

<hr/>


.diff-rm[
```ocaml
*&#x200B;`if true then `1 + 2
*&#x200B;`        else 3 + 4`
```
]

---

## Substitution

```ocaml
&#x200B;
```

<hr/>


```ocaml
1 + 2
```

---

## Formal semantics: conditionals

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond ⇓ ???
```

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

## Formal semantics: conditionals

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Cond `pred` ⇓ ???
```
]

```ocaml
if `true` then 1 + 2
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Cond pred `thenBranch` ⇓ ???
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

## Formal semantics: conditionals

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Cond pred thenBranch `elseBranch` ⇓ ???
```
]

```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

## Formal semantics: conditionals

.diff-add[
```scala
*&#x200B;`pred ⇓ ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ ???
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```

---

## Formal semantics: conditionals

.diff-rm[
```scala
*pred ⇓ `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ ???
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-add[
```scala
*pred ⇓ `true`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ ???
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-add[
```scala
*pred ⇓ true                                         `thenBranch ⇓ n`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ ???
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-rm[
```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Cond pred thenBranch elseBranch ⇓ `???`
```
]

```ocaml
if true then `1 + 2`
        else 3 + 4
```

---

## Formal semantics: conditionals

.diff-add[
```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Cond pred thenBranch elseBranch ⇓ `n`
```
]


```ocaml
if true then `1 + 2`
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-rm[
```scala
*pred ⇓ `true`                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-add[
```scala
*pred ⇓ `false`                                        thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

```ocaml
if true then 1 + 2
        else 3 + 4
```


---

## Formal semantics: conditionals

.diff-rm[
```scala
*pred ⇓ false                                        `thenBranch` ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]


```ocaml
if true then 1 + 2
        else `3 + 4`
```



---

## Formal semantics: conditionals

.diff-add[
```scala
*pred ⇓ false                                        `elseBranch` ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]


```ocaml
if true then 1 + 2
        else `3 + 4`
```

---

## Updated AST: conditionals

```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Updated AST: conditionals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* `case Cond()`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Cond` pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Cond` pred thenBranch elseBranch ⇓ n
```

---

## Updated AST: conditionals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(`pred: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond `pred` thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond `pred` thenBranch elseBranch ⇓ n
```

---

## Updated AST: conditionals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(pred: Expr`, thenBranch: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred `thenBranch` elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred `thenBranch` elseBranch ⇓ n
```

---

## Updated AST: conditionals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
* case Cond(pred: Expr, thenBranch: Expr`, elseBranch: Expr`)
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch `elseBranch` ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch `elseBranch` ⇓ n
```

---

## Interpretation: conditionals

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Interpretation: conditionals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
* `case Cond(pred, t, e) =>`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Cond pred thenBranch elseBranch` ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Cond pred thenBranch elseBranch` ⇓ n
```

---

## Interpretation: conditionals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
*   `if interpret(pred) then`
&#x200B;
```
]

```scala
&#x200B;`pred ⇓ true`                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Interpretation: conditionals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
*   if interpret(pred) then` interpret(t)`
&#x200B;
```
]

```scala
pred ⇓ true                                         `thenBranch ⇓ n`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch `⇓ n`
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Interpretation: conditionals

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
    if interpret(pred) then interpret(t)
*   `else                    interpret(e)`
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        `elseBranch ⇓ n`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch `⇓ n`
```

---

## Interpretation: conditionals

```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
    if `interpret(pred)` then interpret(t)
    else                    interpret(e)
```

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Interpretation: conditionals

```scala
def interpret(expr: Expr): `Int` = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
    if interpret(pred) then interpret(t)
    else                    interpret(e)
```

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Truthiness

.diff-add[
```scala
def interpret(expr: Expr): Int = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
*   if interpret(pred)` != 0` then interpret(t)
*   else              `     `      interpret(e)
```
]

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Actual truth

```scala
enum Value:
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

---

## Actual truth

.diff-add[
```scala
enum Value:
* `case Num(value: Int)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]


---

## Actual truth

.diff-add[
```scala
enum Value:
  case Num(value: Int)
* `case Bool(value: Boolean)`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Actual truth

.diff-rm[
```scala
*def interpret(expr: Expr): `Int` = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
    if interpret(pred) != 0 then interpret(t)
    else                         interpret(e)
```
]

---

## Actual truth

.diff-add[
```scala
*def interpret(expr: Expr): `Value` = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => interpret(lhs) + interpret(rhs)
  case Cond(pred, t, e) =>
    if interpret(pred) != 0 then interpret(t)
    else                         interpret(e)
```
]

---

## Actual truth

.diff-rm[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => value
* case Add(lhs, rhs)    => `interpret(lhs) + interpret(rhs)`
  case Cond(pred, t, e) =>
*   `if interpret(pred) != 0 then interpret(t)`
*   `else                         interpret(e)`
```
]

---

## Actual truth

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => value
* case Add(lhs, rhs)    => `add(lhs, rhs)`
* case Cond(pred, t, e) => `cond(pred, t, e)`
&#x200B;
&#x200B;
```
]


---

## Multiple values: number literals

```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => value
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Num value ⇓ value
```

---

## Multiple values: number literals

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
* case Num(value)       => `Value.Num(value)`
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Num value ⇓ `Value.Num` value
```
]

---

## Multiple values: addition

```scala
def add(lhs: Expr, rhs: Expr) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs ⇓ n1                                                  rhs ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ n1 + n2
```

---

## Multiple values: addition

```scala
def add(lhs: Expr, rhs: Expr) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
*lhs ⇓ `Value.Num` n1                              rhs ⇓ `Value.Num` n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Add lhs rhs ⇓ `Value.Num` n1 + n2
```
]

---

## Multiple values: addition

.diff-rm[
```scala
*def add(lhs: Expr, rhs: Expr) = `???`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num n1                              rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num n1 + n2
```

---

## Multiple values: addition

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
* `(interpret(lhs), interpret(rhs)) match`
*   `case (Value.Num(n1), Value.Num(n2)) =>`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`lhs ⇓ Value.Num n1`                              `rhs ⇓ Value.Num n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num n1 + n2
```

---

## Multiple values: addition

```scala
def add(lhs: Expr, rhs: Expr) =
  (`interpret(lhs)`, interpret(rhs)) match
    case (`Value.Num(n1)`, Value.Num(n2)) =>
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`lhs ⇓ Value.Num n1`                              rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num n1 + n2
```

---

## Multiple values: addition

```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), `interpret(rhs)`) match
    case (Value.Num(n1), `Value.Num(n2)`) =>
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs ⇓ Value.Num n1                              `rhs ⇓ Value.Num n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num n1 + n2
```

---

## Multiple values: addition

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
*   case (Value.Num(n1), Value.Num(n2)) => `Value.Num(n1 + n2)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num n1                              rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ `Value.Num n1 + n2`
```

---

## Multiple values: addition

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(n1), Value.Num(n2)) => Value.Num(n1 + n2)
*   `case _                              => typeError("add")`
&#x200B;
&#x200B;
```
]

```scala
lhs ⇓ Value.Num n1                              rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num n1 + n2
```

---

## Multiple values: conditionals

```scala
def cond(pred: Expr, t: Expr, e: Expr) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
pred ⇓ true                                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ false                                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

```scala
def cond(pred: Expr, t: Expr, e: Expr) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
*pred ⇓ `Value.Bool` true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

.diff-add[
```scala
*pred ⇓ `Value.Bool` false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

---

## Multiple values: conditionals

.diff-rm[
```scala
*def cond(pred: Expr, t: Expr, e: Expr) = `???`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
* `interpret(pred) match`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`pred ⇓` Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
&#x200B;`pred ⇓` Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
*   `case Value.Bool(true)  =>`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`pred ⇓ Value.Bool true`                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
*   case Value.Bool(true)  => `interpret(t)`
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true                              `thenBranch ⇓ n`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ `n`
```

```scala
pred ⇓ Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(t)
*   `case Value.Bool(false) =>`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
&#x200B;`pred ⇓ Value.Bool false`                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(t)
*   case Value.Bool(false) => `interpret(e)`
&#x200B;
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ Value.Bool false                             `elseBranch ⇓ n`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ `n`
```

---

## Multiple values: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(t)
    case Value.Bool(false) => interpret(e)
*   `case _                 => typeError("cond")`
&#x200B;
```
]

```scala
pred ⇓ Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Checking our work

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```


---

## Checking our work

```ocaml
if `true` then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
&#x200B;
```

---

## Formal semantics: boolean literals

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool ⇓ ???
```

---

## Formal semantics: boolean literals

```ocaml
if `true` then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Bool `value` ⇓ ???
```
]

---

## Formal semantics: boolean literals

```ocaml
if true then 1
        else 2
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Bool value ⇓ `Value.Bool value`
```
]

---

## Updated AST: boolean literals

```scala
enum Expr:
  case Num(value: Int)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool value ⇓ Value.Bool value
```

---

## Updated AST: boolean literals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* `case Bool()`
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Bool` value ⇓ Value.Bool value
```

---

## Updated AST: boolean literals

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
* case Bool(`value: Boolean`)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool `value` ⇓ Value.Bool value
```

---

## Interpretation: boolean literals

```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => Value.Num(value)
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool value ⇓ Value.Bool value
```


---

## Interpretation: boolean literals

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => Value.Num(value)
* `case Bool(value)      => ???`
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Bool value` ⇓ Value.Bool value
```

---

## Interpretation: boolean literals

.diff-rm[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => Value.Num(value)
* case Bool(value)      => `???`
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
```
]


```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool value ⇓ `Value.Bool value`
```

---

## Interpretation: boolean literals

.diff-add[
```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => Value.Num(value)
* case Bool(value)      => `Value.Bool(value)`
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool value ⇓ `Value.Bool value`
```

---

## Checking our work

```ocaml
if true then 1
        else 2
```

```scala
val expr = Cond(
  pred       = Bool(true),
  thenBranch = Num(1),
  elseBranch = Num(2)
)
```

---

## Checking our work

```ocaml
&#x200B;`if` true then 1
        else 2
```

```scala
val expr = `Cond`(
  pred       = Bool(true),
  thenBranch = Num(1),
  elseBranch = Num(2)
)
```

---

## Checking our work

```ocaml
if `true` then 1
        else 2
```

```scala
val expr = Cond(
  `pred       = Bool(true)`,
  thenBranch = Num(1),
  elseBranch = Num(2)
)
```

---

## Checking our work

```ocaml
if true `then 1`
        else 2
```

```scala
val expr = Cond(
  pred       = Bool(true),
  `thenBranch = Num(1)`,
  elseBranch = Num(2)
)
```

---

## Checking our work

```ocaml
if true then 1
        `else 2`
```

```scala
val expr = Cond(
  pred       = Bool(true),
  thenBranch = Num(1),
  `elseBranch = Num(2)`
)
```






---

## Checking our work

```ocaml
if true then 1
        else 2
```

```scala
val expr = Cond(
  pred       = Bool(true),
  thenBranch = Num(1),
  elseBranch = Num(2)
)

```

```scala
interpret(expr)
// val res2: Value = Num(1)
```

---

## [Key takeaways](#conclusion)

--

* Conditionals have specific substitution rules

--

* They require supporting booleans in our language

--

* Truthiness is a tool of the devil

---

class: center, middle

# Naming things

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
let x = 1
&#x200B;
x
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>


```ocaml
x
&#x200B;
let x = 1
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + 2
&#x200B;
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  x + 2
&#x200B;
```

---

## Substitution

```ocaml
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let x = 1 in`
*&#x200B;`  `x + 2
&#x200B;
```
]

---

## Substitution

.diff-add[
```ocaml
*&#x200B;`x = 1`
```
]

<hr/>

```ocaml
x + 2
&#x200B;
&#x200B;
```

---

## Substitution

```ocaml
&#x200B;`x` = 1
```

<hr/>

```ocaml
&#x200B;`x` + 2
&#x200B;
&#x200B;
```

---

## Substitution

```ocaml
x = 1
```


<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + 2
&#x200B;
&#x200B;
```
]

---

## Substitution

```ocaml
x = 1
```


<hr/>

.diff-add[
```ocaml
*&#x200B;`1` + 2
&#x200B;
&#x200B;
```
]

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>


```ocaml
let x = 1 in
  x + (let x = 2 in x)
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>


```ocaml
let `x = 1` in
  x + (let x = 2 in x)
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>


```ocaml
let x = 1 in
  `x` + (let x = 2 in x)
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>


```ocaml
let x = 1 in
  x + (let `x = 2` in x)
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>


```ocaml
let x = 1 in
  x + (let x = 2 in `x`)
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
let x = 1 in
* `x` + `(let x = 2 in x)`
&#x200B;
```
]

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let x = 1 in
* `(let x = 2 in x)` + `x`
&#x200B;
```
]

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  (let x = 2 in x) + x
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  (let `x = 2` in x) + x
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  (let x = 2 in `x`) + x
&#x200B;
```

---

## Shadowing

```ocaml
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  (let x = 2 in x) + `x`
&#x200B;
```

---

## Formal Semantics: bindings

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Let ⇓ ???
```

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: bindings

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Let `name` ⇓ ???
```
]

```ocaml
let `x` = 1 in
  x + 2
```


---

## Formal Semantics: bindings

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Let name `value` ⇓ ???
```
]

```ocaml
let x = `1` in
  x + 2
```

---

## Formal Semantics: bindings

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Let name value `body` ⇓ ???
```
]

```ocaml
let x = 1 in
  `x + 2`
```

---

## Formal Semantics: bindings

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Let name `value` body ⇓ ???
```

```ocaml
let x = `1` in
  x + 2
```


---

## Formal Semantics: bindings

.diff-add[
```scala
*&#x200B;`value ⇓ n1`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Let name value body ⇓ ???
```
]

```ocaml
let x = `1` in
  x + 2
```


---

## Formal Semantics: bindings

```scala
value ⇓ n1
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Let name value `body` ⇓ ???
```

```ocaml
let x = 1 in
  `x + 2`
```


---

## Formal Semantics: bindings

.diff-add[
```scala
*&#x200B;`Ε |-` value ⇓ n1
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Let name value body ⇓ ???
```
]

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: bindings

```scala
&#x200B;`Ε |- value ⇓ n1`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ ???
```

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: bindings

.diff-add[
```scala
*Ε |- value ⇓ n1                                     `Ε |- body ⇓ n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ ???
```
]

```ocaml
let x = 1 in
  `x + 2`
```


---

## Formal Semantics: bindings

```scala
Ε |- value ⇓ n1                                     `Ε` |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ ???
```

```ocaml
let x = 1 in
  x + 2
```


---

## Formal Semantics: bindings

.diff-add[
```scala
*Ε |- value ⇓ n1                         Ε`[name <- n1]` |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ ???
```
]

```ocaml
let `x = 1` in
  x + 2
```

---

## Formal Semantics: bindings

.diff-rm[
```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Let name value body ⇓ `???`
```
]

```ocaml
let x = 1 in
  x + 2
```


---

## Formal Semantics: bindings

.diff-add[
```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Let name value body ⇓ `n2`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: variables

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var ⇓ ???
```

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: variables

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Var `name` ⇓ ???
```
]

```ocaml
let x = 1 in
  `x` + 2
```


---

## Formal Semantics: variables

.diff-rm[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;Ε |- Var name ⇓ `???`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

## Formal Semantics: variables

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;Ε |- Var name ⇓ `Ε(name)`
```
]

```ocaml
let x = 1 in
  x + 2
```

---

## Updated AST: bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
&#x200B;
&#x200B;
```
]


```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```


---

## Updated AST: bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
* `case Let()`
&#x200B;
```
]

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Updated AST: bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
* case Let(`name: String`)
&#x200B;
```
]


```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let `name` value body ⇓ n2
```

---

## Updated AST: bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
* case Let(name: String`, value: Expr`)
&#x200B;
```
]


```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name `value` body ⇓ n2
```

---

## Updated AST: bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
* case Let(name: String, value: Expr`, body: Expr`)
&#x200B;
```
]


```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value `body` ⇓ n2
```

---

## Updated AST: variables

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var name ⇓ Ε(name)
```


---

## Updated AST: variables

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
* `case Var()`
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Var` name ⇓ Ε(name)
```

---

## Updated AST: variables

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
* case Var(`name: String`)
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var `name` ⇓ Ε(name)
```

---

## Updated AST: variables

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(`name: String`, value: Expr, body: Expr)
  case Var(`name: String`)
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var name ⇓ Ε(name)
```

---

## Updated AST: variables

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
&#x200B;`Ε` |- Var name ⇓ Ε(name)
```

---

## Environment

.diff-add[
```scala
*case class Env`(map: Map[String, Value])`:
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Environment

.diff-add[
```scala
case class Env(map: Map[String, Value]):
* `def lookup(name: String) =`
*   `map.getOrElse(name, sys.error(s"Unbound variable: $name"))`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Environment

.diff-add[
```scala
case class Env(map: Map[String, Value]):
  def lookup(name: String) =
    map.getOrElse(name, sys.error(s"Unbound variable: $name"))
&#x200B;
* `def bind(name: String, value: Value) =`
*   `Env(map + (name -> value))`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Environment

```scala
case class Env(map: Map[String, Value]):
  def lookup(name: String) =
    map.getOrElse(name, sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    `Env(map + (name -> value))`
&#x200B;
&#x200B;
&#x200B;
```

---

## Environment

.diff-add[
```scala
case class Env(map: Map[String, Value]):
  def lookup(name: String) =
    map.getOrElse(name, sys.error(s"Unbound variable: $name"))
&#x200B;
  def bind(name: String, value: Value) =
    Env(map + (name -> value))
&#x200B;
*&#x200B;`object Env:`
*  `val empty: Env = Env(Map.empty)`
```
]

---

## Environment: interpretation

```scala
def interpret(expr: Expr): Value = expr match
  case Num(value)       => Value.Num(value)
  case Bool(value)      => Value.Bool(value)
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
&#x200B;
```


---

## Environment: interpretation

.diff-add[
```scala
*def interpret(expr: Expr`, env: Env`): Value = expr match
  case Num(value)       => Value.Num(value)
  case Bool(value)      => Value.Bool(value)
  case Add(lhs, rhs)    => add(lhs, rhs)
  case Cond(pred, t, e) => cond(pred, t, e)
&#x200B;
&#x200B;
```
]

---

## Environment: interpretation

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)       => Value.Num(value)
  case Bool(value)      => Value.Bool(value)
* case Add(lhs, rhs)    => add(lhs, rhs`, env`)
* case Cond(pred, t, e) => cond(pred, t, e`, env`)
&#x200B;
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
&#x200B;
```


---

## Environment: number literals

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  `case Num(value)       => Value.Num(value)`
  case Bool(value)      => Value.Bool(value)
  case Add(lhs, rhs)    => add(lhs, rhs, env)
  case Cond(pred, t, e) => cond(pred, t, e, env)
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Num value ⇓ Value.Num value
```

---

## Environment: number literals

```scala
def interpret(expr: Expr, `env: Env`): Value = expr match
  case Num(value)       => Value.Num(value)
  case Bool(value)      => Value.Bool(value)
  case Add(lhs, rhs)    => add(lhs, rhs, env)
  case Cond(pred, t, e) => cond(pred, t, e, env)
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Num value ⇓ Value.Num value
```
]

---

## Environment: boolean literals

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)       => Value.Num(value)
  `case Bool(value)      => Value.Bool(value)`
  case Add(lhs, rhs)    => add(lhs, rhs, env)
  case Cond(pred, t, e) => cond(pred, t, e, env)
&#x200B;
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Bool value ⇓ Value.Bool value
```

---

## Environment: boolean literals

```scala
def interpret(expr: Expr, `env: Env`): Value = expr match
  case Num(value)       => Value.Num(value)
  case Bool(value)      => Value.Bool(value)
  case Add(lhs, rhs)    => add(lhs, rhs, env)
  case Cond(pred, t, e) => cond(pred, t, e, env)
&#x200B;
&#x200B;
```

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Bool value ⇓ Value.Bool value
```
]


---

## Environment: addition

```scala
def add(lhs: Expr, rhs: Expr) =
  (interpret(lhs), interpret(rhs)) match
    case (Value.Num(lhs), Value.Num(rhs)) => Value.Num(lhs + rhs)
    case _                                => typeError("add")
&#x200B;
&#x200B;
&#x200B;
```

```scala
lhs ⇓ Value.Num n1                              rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num (n1 + n2)
```

---

## Environment: addition

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
* (interpret(lhs`, env`), interpret(rhs)) match
    case (Value.Num(lhs), Value.Num(rhs)) => Value.Num(lhs + rhs)
    case _                                => typeError("add")
&#x200B;
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
*&#x200B;`Ε |-` lhs ⇓ Value.Num n1                         rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num (n1 + n2)
```
]

---

## Environment: addition

.diff-add[
```scala
def add(lhs: Expr, rhs: Expr) =
* (interpret(lhs, env), interpret(rhs`, env`)) match
    case (Value.Num(lhs), Value.Num(rhs)) => Value.Num(lhs + rhs)
    case _                                => typeError("add")
&#x200B;
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
*Ε |- lhs ⇓ Value.Num n1                    `Ε |-` rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Add lhs rhs ⇓ Value.Num (n1 + n2)
```
]

---

## Environment: addition

.diff-add[
```scala
*def add(lhs: Expr, rhs: Expr`, env: Env`) =
  (interpret(lhs, env), interpret(rhs, env)) match
    case (Value.Num(lhs), Value.Num(rhs)) => Value.Num(lhs + rhs)
    case _                                => typeError("add")
&#x200B;
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Add lhs rhs ⇓ Value.Num (n1 + n2)
```
]

---

## Environment: conditionals

```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred) match
    case Value.Bool(true)  => interpret(t)
    case Value.Bool(false) => interpret(e)
    case _                 => typeError("cond")
&#x200B;
&#x200B;
```

```scala
pred ⇓ Value.Bool true                              thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

```scala
pred ⇓ Value.Bool false                             elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```

---

## Environment: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
* interpret(pred`, env`) match
    case Value.Bool(true)  => interpret(t)
    case Value.Bool(false) => interpret(e)
    case _                 => typeError("cond")
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
*&#x200B;`Ε |-` pred ⇓ Value.Bool true                         thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

.diff-add[
```scala
*&#x200B;`Ε |-` pred ⇓ Value.Bool false                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

---

## Environment: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred, env) match
*   case Value.Bool(true)  => interpret(t`, env`)
    case Value.Bool(false) => interpret(e)
    case _                 => typeError("cond")
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
*Ε |- pred ⇓ Value.Bool true                    `Ε |-` thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

.diff-add[
```scala
Ε |- pred ⇓ Value.Bool false                        elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

---

## Environment: conditionals

.diff-add[
```scala
def cond(pred: Expr, t: Expr, e: Expr) =
  interpret(pred, env) match
    case Value.Bool(true)  => interpret(t, env)
*   case Value.Bool(false) => interpret(e`, env`)
    case _                 => typeError("cond")
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
Ε |- pred ⇓ Value.Bool true                    Ε |- thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

.diff-add[
```scala
*Ε |- pred ⇓ Value.Bool false                   `Ε |-` elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Cond pred thenBranch elseBranch ⇓ n
```
]

---

## Environment: conditionals

.diff-add[
```scala
*def cond(pred: Expr, t: Expr, e: Expr`, env: Env`) =
  interpret(pred, env) match
    case Value.Bool(true)  => interpret(t, env)
    case Value.Bool(false) => interpret(e, env)
    case _                 => typeError("cond")
&#x200B;
&#x200B;
```
]

.diff-add[
```scala
Ε |- pred ⇓ Value.Bool true                    Ε |- thenBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Cond pred thenBranch elseBranch ⇓ n
```
]

.diff-add[
```scala
Ε |- pred ⇓ Value.Bool false                   Ε |- elseBranch ⇓ n
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*&#x200B;`Ε |-` Cond pred thenBranch elseBranch ⇓ n
```
]

---

## Interpretation: bindings

```scala
def let(name: String, value: Expr, body: Expr, env: Env) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Interpretation: bindings

.diff-rm[
```scala
*def let(name: String, value: Expr, body: Expr, env: Env) = `???`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Interpretation: bindings

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, env: Env) =
* `val n1 = interpret(value, env)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Ε |- value ⇓ n1`                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Interpretation: bindings

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, env: Env) =
  val n1 = interpret(value, env)
* `val n2 = interpret(body, env.bind(name, n1))`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- value ⇓ n1                         `Ε[name <- n1] |- body ⇓ n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Interpretation: bindings

```scala
def let(name: String, value: Expr, body: Expr, env: Env) =
  val n1 = interpret(value, env)
  val n2 = interpret(body, `env.bind(name, n1)`)
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Ε |- value ⇓ n1                         `Ε[name <- n1]` |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```


---

## Interpretation: bindings

.diff-add[
```scala
def let(name: String, value: Expr, body: Expr, env: Env) =
  val n1 = interpret(value, env)
  val n2 = interpret(body, env.bind(name, n1))
&#x200B;
* `n2`
&#x200B;
&#x200B;
```
]

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Let name value body ⇓ `n2`
```

---

## Interpretation: bindings

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
&#x200B;
&#x200B;
```

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```

---

## Interpretation: bindings

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
* `case Let(name, value, body) => let(name, value, body, env)`
&#x200B;
```

```scala
Ε |- value ⇓ n1                         Ε[name <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Let name value body ⇓ n2
```
]

---

## Interpretation: variables

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
&#x200B;
```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var name ⇓ Ε(name)
```


---

## Interpretation: variables

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
* `case Var(name)              =>`
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Var name` ⇓ Ε(name)
```

---

## Interpretation: variables

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
* case Var(name)              => `env.lookup(name)`
```
]

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Var name ⇓ `Ε(name)`
```

---

## Checking out work

```ocaml
let x = 1 in
  (let x = 2 in x) + x
```

--

```scala
val expr = Let(
  name  = "x",
  value = Num(1),
  body  = Add(
    Let(
      name  = "x",
      value = Num(2),
      body  = Var("x")
    ),
    Var("x")))

```

--

```scala
interpret(expr, Env.empty)
// val res3: Value = Num(3)
```

---

## [Key takeaways](#conclusion)

--

* Local bindings have a scope that can be analyzed statically

--

* They can shadowed, but not overwritten

--

* Their interpretation requires an environment

---

class: center, middle

# Reusing Code

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  x + 2
  &#x200B;
  &#x200B;
```

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let x = 1 in
  `x + 2`
  &#x200B;
  &#x200B;
```

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `x = 1` in
  x + 2
  &#x200B;
  &#x200B;
```

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let x = 1 in`
* `x + 2`
&#x200B;
&#x200B;
```
]

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`(x -> x + 2) 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`(x -> x + 2)` 1
&#x200B;
&#x200B;
&#x200B;
```

---

## Generalising local bindings

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
(x -> x + 2) `1`
&#x200B;
&#x200B;
&#x200B;
```

---

## Substitution: functions

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`(x -> x + 2) 1`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Substitution: functions

.diff-add[
```ocaml
*&#x200B;`x = 1`
&#x200B;
&#x200B;
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Substitution: functions

```ocaml
&#x200B;`x` = 1
&#x200B;
&#x200B;
```

<hr/>

```ocaml
&#x200B;`x` + 2
&#x200B;
&#x200B;
&#x200B;
```

---

## Substitution: functions

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + 2
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Substitution: functions

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`1` + 2
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Substitution: functions

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`1 + 2`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Substitution: functions

```ocaml
x = 1
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3`
&#x200B;
&#x200B;
&#x200B;
```
]

---

## Naming functions

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-add[
```ocaml
let f = x -> x + 2 in
  f 1
&#x200B;
&#x200B;
```
]

---

## Naming functions

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f = `x -> x + 2` in
  f 1
&#x200B;
&#x200B;
```

---

## Naming functions

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `f` = x -> x + 2 in
  f 1
&#x200B;
&#x200B;
```

---

## Naming functions

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let f = x -> x + 2 in
  `f 1`
&#x200B;
&#x200B;
```

---

## Updated Value: functions

```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
&#x200B;
```

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Updated Value: functions

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* `case Fun()`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Updated Value: functions

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(`param: String`)
```
]

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

## Updated Value: functions

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(param: String`, body: Expr`)
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```


---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```


---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      `f 3`
```


---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let y = 1 in`
*&#x200B;`  `let f = x -> x + y in
*&#x200B;`  `  let y = 2 in
*&#x200B;`  `    f 3
```
]

---

## Static scoping

.diff-add[
```ocaml
*&#x200B;`y = 1`
&#x200B;
&#x200B;
```
]

<hr/>

```ocaml
let f = x -> x + y in
  let y = 2 in
    f 3
&#x200B;
```

---

## Static scoping

```ocaml
y = 1
&#x200B;
&#x200B;
```


<hr/>

.diff-rm[
```ocaml
*&#x200B;`let f = x -> x + y in`
*&#x200B;`  `let y = 2 in
*&#x200B;`  `  f 3
&#x200B;
```
]

---

## Static scoping

.diff-add[
```ocaml
y = 1
*&#x200B;`f = x -> x + y`
&#x200B;
```
]


<hr/>

```ocaml
let y = 2 in
  f 3
&#x200B;
```

---

## Static scoping

.diff-rm[
```ocaml
*&#x200B;`y = 1`
f = x -> x + y
&#x200B;
```
]

<hr/>

.diff-rm[
```ocaml
*&#x200B;`let y = 2 in`
&#x200B;`  `f 3
&#x200B;
```
]

---

## Static scoping

.diff-add[
```ocaml
*&#x200B;`y = 2`
f = x -> x + y
&#x200B;
```
]

<hr/>

.diff-rm[
```ocaml
f 3
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
&#x200B;`f` = x -> x + y
&#x200B;
```

<hr/>

```ocaml
&#x200B;`f` 3
&#x200B;
&#x200B;
```

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
&#x200B;
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`f 3`
&#x200B;
&#x200B;
```
]

---

## Static scoping

.diff-add[
```ocaml
y = 2
f = x -> x + y
*&#x200B;`x = 3`
```
]

<hr/>

.diff-add[
```ocaml
*&#x200B;`x + y`
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
&#x200B;`x` = 3
```

<hr/>

```ocaml
&#x200B;`x` + y
&#x200B;
&#x200B;
```

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`x` + y
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`3` + y
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
&#x200B;`y` = 2
f = x -> x + y
x = 3
```

<hr/>

```ocaml
&#x200B;3 + `y`
&#x200B;
&#x200B;
```

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;3 + `y`
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;3 + `2`
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-rm[
```ocaml
*&#x200B;`3 + 2`
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
y = 2
f = x -> x + y
x = 3
```

<hr/>

.diff-add[
```ocaml
*&#x200B;`5`
&#x200B;
&#x200B;
```
]

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let f = x -> x + y in
    let `y = 2` in
      f 3
```

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let `y = 1` in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

---

## Static scoping

```ocaml
&#x200B;
&#x200B;
&#x200B;
```

<hr/>

```ocaml
let y = 1 in
  let `f = x -> x + y` in
    let y = 2 in
      f 3
```

---

## Updated Value: closures

```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Fun(param: String, body: Expr)
```


---

## Updated Value: closures

.diff-add[
```scala
enum Value:
  case Num(value: Int)
  case Bool(value: Boolean)
* case Fun(param: String, body: Expr`, env: Env`)
```
]

---

## Formal Semantics: functions

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun ⇓ ???
```

```ocaml
let f = `x -> x + 2` in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun `param` ⇓ ???
```
]

```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param `body` ⇓ ???
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

## Formal Semantics: functions

.diff-rm[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param body ⇓ `???`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param body ⇓ `Value.Fun`
```
]

```ocaml
let f = x -> `x + 2` in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param body ⇓ Value.Fun `param`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param body ⇓ Value.Fun param `body`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: functions

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Fun param body ⇓ Value.Fun param body `E`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply ⇓ ???
```

```ocaml
let f = x -> x + 2 in
  `f 1`
```

---

## Formal Semantics: application

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply `fun` ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

## Formal Semantics: application

.diff-add[
```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun `arg` ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f `1`
```

---

## Formal Semantics: application

.diff-add[
```scala
*&#x200B;`Ε |- fun ⇓ ???`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

## Formal Semantics: application

.diff-rm[
```scala
*Ε |- fun ⇓ `???`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

## Formal Semantics: application

.diff-add[
```scala
*Ε |- fun ⇓ `Value.Fun param body Ε′`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  `f` 1
```

---

## Formal Semantics: application

.diff-add[
```scala
*Ε |- fun ⇓ Value.Fun param body Ε′                    `Ε |- arg ⇓ n1`
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f `1`
```

---

## Formal Semantics: application

.diff-add[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*&#x200B;`??? |- body ⇓ ???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]


```ocaml
let f = x -> `x + 2` in
  f 1
```

---

## Formal Semantics: application

.diff-rm[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*&#x200B;`???` |- body ⇓ ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]


```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

.diff-add[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*&#x200B;`Ε′` |- body ⇓ ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]


```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′ |- body ⇓ ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```


```ocaml
let f = `x` -> x + 2 in
  f 1
```

---

## Formal Semantics: application

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′ |- body ⇓ ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```


```ocaml
let f = x -> x + 2 in
  f `1`
```

---

## Formal Semantics: application

.diff-add[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*Ε′`[param <- n1]` |- body ⇓ ???
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

.diff-rm[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*Ε′[param <- n1] |- body ⇓ `???`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

.diff-add[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
*Ε′[param <- n1] |- body ⇓ `n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ ???
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

.diff-rm[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Apply fun arg ⇓ `???`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Formal Semantics: application

.diff-add[
```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Apply fun arg ⇓ `n2`
```
]

```ocaml
let f = x -> x + 2 in
  f 1
```

---

## Updated AST: functions

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
&#x200B;
&#x200B;
```

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun param body ⇓ Value.Fun param body E
```

---

## Updated AST: functions

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
* `case Fun()`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Fun` param body ⇓ Value.Fun param body E
```

---

## Updated AST: functions

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
* case Fun(`param: String`)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun `param` body ⇓ Value.Fun param body E
```

---

## Updated AST: functions

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
* case Fun(param: String`, body: Expr`)
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun param `body` ⇓ Value.Fun param body E
```

---

## Updated AST: application

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
&#x200B;
```

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```


---

## Updated AST: application

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
* `case Apply()`
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Apply` function arg ⇓ n2
```

---

## Updated AST: application

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
* case Apply(`function: Expr`)
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply `fun` arg ⇓ n2
```

---

## Updated AST: application

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
* case Apply(fun: Expr`, arg: Expr`)
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′                    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun `arg` ⇓ n2
```

---

## Interpretation: functions

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
&#x200B;
&#x200B;
```


```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun param body ⇓ Value.Fun param body Ε
```


---

## Interpretation: functions

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
* `case Fun(param, body)  => ???`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Fun param body` ⇓ Value.Fun param body Ε
```

---

## Interpretation: functions

.diff-rm[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
* case Fun(param, body)  => `???`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun param body ⇓ Value.Fun param body Ε
```

---

## Interpretation: functions

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
* case Fun(param, body)       => `Value.Fun(param, body, env)`
&#x200B;
```
]

```scala
&#x200B;
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Fun param body ⇓ `Value.Fun param body Ε`
```

---

## Interpretation: application

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, env)
&#x200B;
```


```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, env)
* `case Apply(fun, arg)   => apply(fun, arg, env)`
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-rm[
```scala
*def apply(fun: Expr, arg: Expr, env: Env) = `???`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
* `interpret(fun, env) match`
*   `case Value.Fun(param, body, env2) =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Ε |- fun ⇓ Value.Fun param body Ε′`    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
  interpret(fun, env) match
    case Value.Fun(param, body, env2) =>
*     `val n1 = interpret(arg, env)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    `Ε |- arg ⇓ n1`
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
  interpret(fun, env) match
    case Value.Fun(param, body, env2) =>
      val n1 = interpret(arg, env)
*     `val n2 = interpret(body, env2.bind(param, n1))`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
&#x200B;`Ε′[param <- n1] |- body ⇓ n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Interpretation: application

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
  interpret(fun, env) match
    case Value.Fun(param, body, env2) =>
      val n1 = interpret(arg, env)
      val n2 = interpret(body, env2.bind(param, n1))
&#x200B;
*     `n2`
&#x200B;
&#x200B;
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ `n2`
```

---

## Interpretation: application

.diff-add[
```scala
def apply(fun: Expr, arg: Expr, env: Env) = ???
  interpret(fun, env) match
    case Value.Fun(param, body, env2) =>
      val n1 = interpret(arg, env)
      val n2 = interpret(body, env2.bind(param, n1))
&#x200B;
      n2
&#x200B;
*   `case _ => typeError("apply")`
```
]

```scala
Ε |- fun ⇓ Value.Fun param body Ε′    Ε |- arg ⇓ n1
Ε′[param <- n1] |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Apply fun arg ⇓ n2
```

---

## Checking our work

```ocaml
let y = 1 in
  let f = x -> x + y in
    let y = 2 in
      f 3
```

--

```scala
val expr = Let(
  ...
)
```

--

```scala
interpret(expr, Env.empty)
// val res4: Value = Num(4)
```

---

## Multi-parameter functions

```ocaml
let add = ??? in
  add 1 2
```

---

## Multi-parameter functions

.diff-rm[
```ocaml
*let add = `???` in
  add 1 2
```
]

---

## Multi-parameter functions

.diff-add[
```ocaml
*let add = `x -> ???` in
  add 1 2
```
]

---

## Multi-parameter functions

.diff-rm[
```ocaml
*let add = x -> `???` in
  add 1 2
```
]

---

## Multi-parameter functions

.diff-add[
```ocaml
*let add = x -> `y -> x + y` in
  add 1 2
```
]


---

## Multi-parameter functions

```ocaml
let add = x -> y -> x + y in
  add 1 2
```

```scala
val expr = Let(
  ...
)
```

--

```scala
interpret(expr, Env.empty)
// val res5: Value = Num(3)
```

---

## [Key takeaways](#conclusion)

--

* Functions are values

--

* They _close_ over their environment

--

* something something

---

class: center, middle

# Repeating actions
---

## Sum numbers in a range

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

## Sum numbers in a range

```ocaml
fun sumFor lower upper =
  var acc = 0
  for i = lower to upper do
    acc = acc + i
  acc
```

---

## Testing recursion

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

## Testing recursion

```ocaml
let sum = lower -> upper ->
    if lower `>` upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

## Formal semantics: comparison

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt ⇓ ???
```

```ocaml
if 1 > 2 then false
         else true
```

---

## Formal semantics: comparison

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Gt `lhs` ⇓ ???
```
]

```ocaml
if `1` > 2 then false
         else true
```

---

## Formal semantics: comparison

.diff-add[
```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Gt lhs `rhs` ⇓ ???
```
]

```ocaml
if 1 > `2` then false
         else true
```

---

## Formal semantics: comparison

.diff-add[
```scala
*&#x200B;`Ε |- lhs ⇓ Value.Num n1`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ ???
```
]

```ocaml
if `1` > 2 then false
         else true
```


---

## Formal semantics: comparison

.diff-add[
```scala
*Ε |- lhs ⇓ Value.Num n1                    `Ε |- rhs ⇓ Value.Num n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ ???
```
]

```ocaml
if 1 > `2` then false
         else true
```


---

## Formal semantics: comparison

.diff-rm[
```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Gt lhs rhs ⇓ `???`
```
]

```ocaml
if `1 > 2` then false
         else true
```



---

## Formal semantics: comparison

.diff-add[
```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
*Ε |- Gt lhs rhs ⇓ `Value.Bool (n1 > n2)`
```
]

```ocaml
if `1 > 2` then false
         else true
```

---

## Updated AST: comparison

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
```

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Updated AST: comparison

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* `case Gt()`
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Gt` lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Updated AST: comparison

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* case Gt(`lhs: Expr`)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt `lhs` rhs ⇓ Value.Bool (n1 > n2)
```

---

## Updated AST: comparison

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
* case Gt(lhs: Expr`, rhs: Expr`)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs `rhs` ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, env)
  case Apply(fun, arg)        => apply(fun, arg, env)
&#x200B;
```

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```


---

## Interpretation: comparison

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
* `case Gt(lhs, rhs)           =>`
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, env)
  case Apply(fun, arg)        => apply(fun, arg, env)
```
]


```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- `Gt lhs rhs` ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

.diff-add[
```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)             => Value.Num(value)
  case Bool(value)            => Value.Bool(value)
  case Add(lhs, rhs)          => add(lhs, rhs, env)
* case Gt(lhs, rhs)           => `gt(lhs, rhs, env)`
  case Cond(pred, t, e)       => cond(pred, t, e, env)
  case Let(name, value, body) => let(name, value, body, env)
  case Var(name)              => env.lookup(name)
  case Fun(param, body)       => Value.Fun(param, body, env)
  case Apply(fun, arg)        => apply(fun, arg, env)
```
]


```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

```scala
def gt(lhs: Expr, rhs: Expr, env: Env) = ???
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

.diff-rm[
```scala
*def gt(lhs: Expr, rhs: Expr, env: Env) = `???`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, env: Env) =
* `(interpret(lhs, env), interpret(rhs, env)) match`
*   `case (Value.Num(n1), Value.Num(n2)) =>`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
&#x200B;`Ε |- lhs ⇓ Value.Num n1`                    `Ε |- rhs ⇓ Value.Num n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

```scala
def gt(lhs: Expr, rhs: Expr, env: Env) =
  (`interpret(lhs, env)`, interpret(rhs, env)) match
    case (`Value.Num(n1)`, Value.Num(n2)) =>
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
&#x200B;`Ε |- lhs ⇓ Value.Num n1`                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```

---

## Interpretation: comparison

```scala
def gt(lhs: Expr, rhs: Expr, env: Env) =
  (interpret(lhs, env), `interpret(rhs, env)`) match
    case (Value.Num(n1), `Value.Num(n2)`) =>
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```

```scala
Ε |- lhs ⇓ Value.Num n1                    `Ε |- rhs ⇓ Value.Num n2`
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ Value.Bool (n1 > n2)
```


---

## Interpretation: comparison

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, env: Env) =
  (interpret(lhs, env), interpret(rhs, env)) match
*   case (Value.Num(n1), Value.Num(n2)) => `Value.Bool(lhs > rhs)`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ `Value.Bool (n1 > n2)`
```

---


## Interpretation: comparison

.diff-add[
```scala
def gt(lhs: Expr, rhs: Expr, env: Env) =
  (interpret(lhs, env), interpret(rhs, env)) match
    case (Value.Num(n1), Value.Num(n2)) => Value.Bool(lhs > rhs)
*   `case _                              => typeError("gt")`
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
&#x200B;
```
]

```scala
Ε |- lhs ⇓ Value.Num n1                    Ε |- rhs ⇓ Value.Num n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- Gt lhs rhs ⇓ `Value.Bool (n1 > n2)`
```

---

## Testing recursion

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

--

```scala
val expr = Let(
  ...
)
```

--

```scala
interpret(expr, Env.empty)
// ⛔ Unbound variable: sum
```

---

## Substitution: recursive bindings

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

---

## Updated AST: recursive bindings

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
&#x200B;
```

---

## Updated AST: recursive bindings

.diff-add[
```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
* `case LetRec(name: String, value: Expr, body: Expr)`
  case Var(name: String)
  case Fun(param: String, body: Expr)
  case Apply(fun: Expr, arg: Expr)
```
]

---

## Updated AST: recursive bindings

```scala
Ε′ = Ε[name <- null]; Ε′ |- value ⇓ n1
update(Ε′, name, n1); Ε′ |- body ⇓ n2
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Ε |- LetRec name value body ⇓ n2
```

---

## Interpretation: recursive bindings

```scala
def let(name: String, value: Expr, body: Expr, env: Env) =
  val actualValue = interpret(value, env)
  val newEnv      = env.bind(name, actualValue)

  interpret(body, newEnv)
```

---

## Interpretation: recursive bindings

```scala
def letRec(name: String, value: Expr, body: Expr, env: Env) =
  val actualValue = interpret(value, env)
  val newEnv      = env.bind(name, actualValue)

  interpret(body, newEnv)
```

---

## Interpretation: recursive bindings

```scala
def letRec(name: String, value: Expr, body: Expr, env: Env) =
  interpret(value, env) match
    case function: Value.Fun =>
      val newEnv = env.bind(name, actualValue)
      interpret(body, newEnv)
```

---

## Interpretation: recursive bindings

```scala
case class Env(map: mutable.Map[String, Value]):
  def lookup(name: String) =
    map.getOrElse(name, sys.error(s"Unbound variable: $name"))

  def bind(name: String, value: Value) =
    Env(map ++ mutable.Map(name -> value))

  def set(name: String, value: Value) =
    map += (name -> value)

object Env:
  val empty: Env = Env(mutable.Map.empty)

```

---

## Interpretation: recursive bindings

```scala
def letRec(name: String, value: Expr, body: Expr, env: Env) =
  val newEnv = env.bind(name, null)

  interpret(value, newEnv) match
    case function: Value.Fun =>
      newEnv.set(name, function)
      interpret(body, newEnv)

    case _ => typeError("letRec")
```

---

## Interpretation: recursive bindings

```scala
def interpret(expr: Expr, env: Env): Value = expr match
  case Num(value)                => Value.Num(value)
  case Bool(value)               => Value.Bool(value)
  case Add(lhs, rhs)             => add(lhs, rhs, env)
  case Gt(lhs, rhs)              => gt(lhs, rhs, env)
  case Cond(pred, t, e)          => cond(pred, t, e, env)
  case Let(name, value, body)    => let(name, value, body, env)
  case LetRec(name, value, body) => letRec(name, value, body, env)
  case Var(name)                 => env.lookup(name)
  case Fun(param, body)          => Value.Fun(param, body, env)
  case Apply(fun, arg)           => apply(fun, arg, env)
```

---

## Checking our work

```ocaml
let rec sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

--

```scala
val expr = LetRec
  ...
)
```

--

```scala
interpret(expr, Env.empty)
// val res6: Value = Num(55)
```

---

## [Key takeaways](#conclusion)

* Loops are implemented as recursive functions

--

* Recursive functions need special syntax

--

* Recursive functions force our environment to be mutable

---

class: center, middle

# Identifying invalid programs
---

## Invalid program

```scala
val nonsense = Add(
  Num(1),
  Bool(true)
)

```

--

```scala
interpret(nonsense, Env.empty)
// java.lang.RuntimeException: Type error in add
//   at scala.sys.package$.error(package.scala:27)
//   at <console>.typeError(<console>:7)
//   at <console>.add(<console>:37)
//   at <console>.interpret(<console>:78)
//   ... 36 elided
```

---

## Type checking

```scala
def typeCheck(expr: Expr): ??? = ???
```

---

## Type checking

```scala
enum Type:
  case Num
  case Bool
```

---

## Type checking

```scala
enum Type:
  case Num
  case Bool
  case Fun(from: Type, to: Type)

```

---

## Type checking

```scala
def typeCheck(expr: Expr): Either[String, Type] = ???

```

---

## Literal values

```scala
def typeCheck(expr: Expr): Either[String, Type] = expr match
  case Num(value)  => ???
```

--

```scala
|- Num n : Type.Num
```

---

## Literal values

```scala
def typeCheck(expr: Expr): Either[String, Type] = expr match
  case Num(value)  => Right(Type.Num)
```

```scala
|- Num n : Type.Num
```

---

## Literal values

```scala
def typeCheck(expr: Expr): Either[String, Type] = expr match
  case Num(value)  => Right(Type.Num)
  case Bool(value) => ???
```

--

```scala
|- Bool b : Type.Bool
```

---

## Literal values

```scala
def typeCheck(expr: Expr): Either[String, Type] = expr match
  case Num(value)  => Right(Type.Num)
  case Bool(value) => Right(Type.Bool)
```

```scala
|- Bool b : Type.Bool
```

---

## Simple functions

```scala
|- lhs : Type.Num                                |- rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
|- Add lhs rhs : Type.Num
```

---

## Simple functions

```scala
def expectNum(expr: Expr) =
  typeCheck(expr).flatMap { observed =>
    Either.cond(
      test  = observed == Type.Num,
      left  = s"Expected Num, found $observed",
      right = observed
    )
  }

```

---

## Simple functions

```scala
def expect(expr: Expr, expected: Type) =
  typeCheck(expr).flatMap { observed =>
    Either.cond(
      test  = observed == expected,
      left  = s"Expected $expected, found $observed",
      right = observed
    )
  }

```

---

## Simple functions

```scala
def checkAdd(lhs: Expr, rhs: Expr) = for
  _ <- expect(lhs, Type.Num)
  _ <- expect(rhs, Type.Num)
yield Type.Num

```

```scala
|- lhs : Type.Num                                |- rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
|- Add lhs rhs : Type.Num
```


---

## Simple functions

```scala
def checkGt(lhs: Expr, rhs: Expr) = for
  _ <- expect(lhs, Type.Num)
  _ <- expect(rhs, Type.Num)
yield Type.Bool

```

```scala
|- lhs : Type.Num                                |- rhs : Type.Num
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
|- Gt lhs rhs : Type.Bool
```


---

## Simple functions

```scala
def typeCheck(expr: Expr) = expr match
  case Num(value)    => Right(Type.Num)
  case Bool(value)   => Right(Type.Bool)
  case Add(lhs, rhs) => checkAdd(lhs, rhs)
  case Gt(lhs, rhs)  => checkGt(lhs, rhs)
```

---

## Conditional

```scala
def checkCond(pred: Expr, t: Expr, e: Expr) =
  for
    _      <- expect(pred, Type.Bool)
    x      <- typeCheck(t)
    _      <- expect(e, x)
  yield x

```

```scala
|- pred : Type.Bool               |- t : X                |- e : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
|- Cond pred t e : X
```

---

## Conditional

```scala
def typeCheck(expr: Expr) = expr match
  case Num(value)       => Right(Type.Num)
  case Bool(value)      => Right(Type.Bool)
  case Add(lhs, rhs)    => checkAdd(lhs, rhs)
  case Gt(lhs, rhs)     => checkGt(lhs, rhs)
  case Cond(pred, t, e) => checkCond(pred, t, e)
```

---

## Local bindings

```scala
Γ |- value : X                             Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Let name value body : Y
```

---

## Local bindings

```scala
case class TypeEnv(map: immutable.Map[String, Type]) {
  def bind(name: String, tpe: Type) = TypeEnv(map + (name -> tpe))

  def lookup(name: String) = map.get(name) match
    case Some(tpe) => Right(tpe)
    case None      => Left(s"Type binding $name not found")
}

object TypeEnv:
  val empty = TypeEnv(immutable.Map.empty)

```

---

## Local bindings

```scala
def checkLet(name: String, value: Expr, body: Expr, env: TypeEnv) =
  for
    x <- typeCheck(value, env)
    y <- typeCheck(body, env.bind(name, x))
  yield y

```

```scala
Γ |- value : X                            Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Let name value body : Y
```


---

## Local bindings

```scala
def checkVar(name: String, env: TypeEnv) =
  env.lookup(name)

```

```scala
&#x200B;
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Var name : Γ(name)
```

---

## Local bindings

```scala
def typeCheck(expr: Expr, env: TypeEnv): Either[String, Type] = expr match
  case Num(value)             => Right(Type.Num)
  case Bool(value)            => Right(Type.Bool)
  case Add(lhs, rhs)          => checkAdd(lhs, rhs, env)
  case Gt(lhs, rhs)           => checkGt(lhs, rhs, env)
  case Cond(pred, t, e)       => checkCond(pred, t, e, env)
  case Let(name, value, body) => checkLet(name, value, body, env)
  case Var(name)              => checkVar(name, env)
```

---

## Functions

```scala
Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun name body : X -> Y
```

---

## Functions

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, body: Expr)
  case Var(name: String )
  case Fun(param: String, paramType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)

```

---

## Functions

```scala
def checkFun(name: String, x: Type, body: Expr, env: TypeEnv) =
  typeCheck(body, env.bind(name, x)).map { y =>
    Type.Fun(x, y)
  }

```

```scala
Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Fun name body : X -> Y
```


---

## Functions

```scala
Γ |- fun : X -> Y                                     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Apply fun arg : Y
```

---

## Functions

```scala
def expectFun(expr: Expr, env: TypeEnv) =
  typeCheck(expr, env).flatMap {
    case f: Type.Fun => Right(f)
    case other       => typeError("function")
  }

```

---

## Functions

```scala
def checkApply(fun: Expr, arg: Expr, env: TypeEnv) =
  expectFun(fun, env).flatMap { case Type.Fun(x, y) =>
    expect(arg, x, env)
      .map(_ => y)
  }

```

```scala
Γ |- fun : X -> Y                                     Γ |- arg : X
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- Apply fun arg : Y
```


---

## Functions

```scala
def typeCheck(expr: Expr, env: TypeEnv): Either[String, Type] = expr match
  case Num(value)             => Right(Type.Num)
  case Bool(value)            => Right(Type.Bool)
  case Add(lhs, rhs)          => checkAdd(lhs, rhs, env)
  case Gt(lhs, rhs)           => checkGt(lhs, rhs, env)
  case Cond(pred, t, e)       => checkCond(pred, t, e, env)
  case Let(name, value, body) => checkLet(name, value, body, env)
  case Var(name)              => checkVar(name, env)
  case Apply(fun, arg)        => checkApply(fun, arg, env)
  case Fun(param, paramType, body) =>
    checkFun(param, paramType, body, env)
```

---

## Recursive functions

```scala
Γ[name <- X] |- value : X                  Γ[name <- X] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- LetRec name (value : X) body : Y
```

---

## Recursive functions

```scala
enum Expr:
  case Num(value: Int)
  case Bool(value: Boolean)
  case Add(lhs: Expr, rhs: Expr)
  case Gt(lhs: Expr, rhs: Expr)
  case Cond(pred: Expr, thenBranch: Expr, elseBranch: Expr)
  case Let(name: String, value: Expr, body: Expr)
  case LetRec(name: String, value: Expr, valueType: Type.Fun, body: Expr)
  case Var(name: String)
  case Fun(param: String, paramType: Type, body: Expr)
  case Apply(fun: Expr, arg: Expr)

```

---

## Recursive functions

```scala
def checkLetRec(name: String, value: Expr,
                valueType: Type.Fun, body: Expr,
                env: TypeEnv) =
  val newEnv = env.bind(name, valueType)

  for
    _ <- expect(value, valueType, newEnv)
    y <- typeCheck(body, newEnv)
  yield y

```

```scala
Γ[name <- (I -> O)] |- value : I -> O
Γ[name <- (I -> O)] |- body : Y
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
Γ |- LetRec name (value : I -> O) body : Y
```


---

## Recursive functions

```scala
def typeCheck(expr: Expr, env: TypeEnv): Either[String, Type] = expr match
  case Num(value)             => Right(Type.Num)
  case Bool(value)            => Right(Type.Bool)
  case Add(lhs, rhs)          => checkAdd(lhs, rhs, env)
  case Gt(lhs, rhs)           => checkGt(lhs, rhs, env)
  case Cond(pred, t, e)       => checkCond(pred, t, e, env)
  case Let(name, value, body) => checkLet(name, value, body, env)
  case Var(name)              => checkVar(name, env)
  case Apply(fun, arg)        => checkApply(fun, arg, env)

  case Fun(param, paramType, body) =>
    checkFun(param, paramType, body, env)

  case LetRec(name, value, valueType, body) =>
    checkLetRec(name, value, valueType, body, env)

```

---

## Checking our work

```ocaml
let sum = lower -> upper ->
    if lower > upper then 0
    else lower + (sum (lower + 1) upper)
  in sum 1 10
```

--

```scala
typeCheck(expr, TypeEnv.empty)
// val res8: Either[String, Type] = Right(Num)
```

---
class: center, middle
name: conclusion

# In closing

---

## If you only remember 1 slide...

--

* ADTs make data structures simpler and safer.

--

* So do GADTs, only more so.

--

* Thinking about data structures that way will have a lasting impact on the way you write code.

---

class: center, middle
name: questions

[<img src="img/qr-code.svg" width="50%" height="50%"/>][Slides]

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]

---

class: center, middle

# Typed Expression

---

```scala
enum TypedExpr[A]:
  case Num(value: Int) extends TypedExpr[Type.Num.type]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool.type]
  case Add(lhs: TypedExpr[Type.Num.type], rhs: TypedExpr[Type.Num.type]) extends TypedExpr[Type.Num.type]
  case Gt(lhs: TypedExpr[Type.Num.type], rhs: TypedExpr[Type.Num.type]) extends TypedExpr[Type.Bool.type]
  case Cond[A](pred: TypedExpr[Type.Bool.type], thenBranch: TypedExpr[A], elseBranch: TypedExpr[A]) extends TypedExpr[A]
  case Let[A, B](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A](name: String, value: TypedExpr[Type.Fun], body: TypedExpr[A]) extends TypedExpr[A]
  case Var[A](name: String) extends TypedExpr[A]
  case Fun[A](param: String, body: TypedExpr[A]) extends TypedExpr[Type.Fun]
  case Apply[A, B](fun: TypedExpr[Type.Fun], arg: TypedExpr[A]) extends TypedExpr[B]

```

---

```scala
enum Type:
  case Num
  case Bool
  case Fun(from: Type, to: Type)

object Type:
  type Num = Type.Num.type
  type Bool = Type.Bool.type

```

---

```scala
enum TypedExpr[A]:
  case Num(value: Int) extends TypedExpr[Type.Num]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool]
  case Add(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Num]
  case Gt(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Bool]
  case Cond[A](pred: TypedExpr[Type.Bool], thenBranch: TypedExpr[A], elseBranch: TypedExpr[A]) extends TypedExpr[A]
  case Let[A, B](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A](name: String, value: TypedExpr[Type.Fun], body: TypedExpr[A]) extends TypedExpr[A]
  case Fun[A](param: String, body: TypedExpr[A]) extends TypedExpr[Type.Fun]
  case Var[A](name: String) extends TypedExpr[A]
  case Apply[A, B](fun: TypedExpr[Type.Fun], arg: TypedExpr[A]) extends TypedExpr[B]

```

---

```scala
enum Type:
  case Num
  case Bool
  case Fun[From <: Type, To <: Type](from: From, to: To)

object Type:
  type Num = Type.Num.type
  type Bool = Type.Bool.type

type ->[A <: Type, B <: Type] = Type.Fun[A, B]

```

---

```scala
enum TypedExpr[A <: Type]:
  case Num(value: Int) extends TypedExpr[Type.Num]
  case Bool(value: Boolean) extends TypedExpr[Type.Bool]
  case Add(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Num]
  case Gt(lhs: TypedExpr[Type.Num], rhs: TypedExpr[Type.Num]) extends TypedExpr[Type.Bool]
  case Cond[A <: Type](pred: TypedExpr[Type.Bool], thenBranch: TypedExpr[A], elseBranch: TypedExpr[A]) extends TypedExpr[A]
  case Let[A <: Type, B <: Type](name: String, value: TypedExpr[A], body: TypedExpr[B]) extends TypedExpr[B]
  case LetRec[A <: Type, B <: Type, C <: Type](name: String, value: TypedExpr[A -> B], body: TypedExpr[C]) extends TypedExpr[C]
  case Var[A <: Type](name: String) extends TypedExpr[A]
  case Fun[A <: Type, B <: Type](param: String, body: TypedExpr[B]) extends TypedExpr[A -> B]
  case Apply[A <: Type, B <: Type](fun: TypedExpr[A -> B], arg: TypedExpr[A]) extends TypedExpr[B]

```

---

```scala
import TypedExpr.*
Let(
  name  = "x",
  value = Bool(true),
  body  = Add(Var("x"), Num(1))
)
// val res9: TypedExpr[Type.Num.type] = Let(x,Bool(true),Add(Var(x),Num(1)))
```

---

```scala
val expr: TypedExpr[Type.Bool -> Type.Num] = Fun(
  param = "x",
  body  = Add(Var("x"), Num(1))
)

```

---



[@NicolasRinaudo@functional.cafe]:https://functional.cafe/@NicolasRinaudo
[Nicolas Rinaudo]:https://nrinaudo.github.io/
[Slides]:https://nrinaudo.github.io/writing-pl/#1
    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>


4165387427862093
